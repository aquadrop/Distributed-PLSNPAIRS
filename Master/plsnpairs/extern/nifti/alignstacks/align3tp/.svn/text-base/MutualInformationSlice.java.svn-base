package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the normalized mutual information for slices from * two ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional ROI. * It works on a 2D slices using the roi from an ImageJ ImageProcessor. * Normalized mutual information = I(A,B)/H(A,B), where I(A,B) is the * mutual information and H(A,B) is the mutual entropy.  Normalization * ameliorates the problem of the overlap of slices.  Entropy, * H(A,B) = sum(pdf(a,b)*log(1/pdf(a,b))).  The pair, (a,b), represtents * the values in the two slices at the same point A(x,y)=a and B(x,y)=b. * The probability density function pdf(a,b) is the number of corresponding * pixels in each image with values, (a,b), divided by the number of * overlapping pixels. * Mutual information = I(A,B) = sum(pdf(a,b)*log(pdf(a,b)/(pdf(a)*pdf(b)))) * For implementation, the pixel values need to be divided in discrete * values.  The number of values is given by bins  The pdf is a two * dimensional histogram, bins by bins in size.  Pixel values are mapped * to bins by slope*(value-min).  Values less than 0 are mapped to 0. * Values more than bins-1 are mapped to bins-1. * Range for normalized mutual information is 0 to 1 if the overlap is * adequate. * The normalized mutual information is multiplied by the change penalty * [0,1] calculated in SliceFunction.  If the overlap is less than * minOverlap, then -distanceSq/halfPenaltySq is returned, [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param roi calculation is limited to the region in roi * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class MutualInformationSlice extends SliceFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip = new ImageProcessor[2];	private int bins = 256, binsSq = bins*bins;	private float[] min = {0F, 0F}, max = {255F, 255F};	private int[] npix = {0, 0};	/** Constructor for MutualInformation on two slices without an ROI using	 * default transformation. */	public MutualInformationSlice(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for MutualInformation on two slices without an ROI. */	public MutualInformationSlice(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for MutualInformation on two slices with an ROI and	  * the transform specified. */	public MutualInformationSlice(ImagePlusPlus[] imppIn, int transform,			Roi roi) throws IllegalArgumentException, ArithmeticException {		super(imppIn, transform, roi);		// get ip[0], max[k], and min[k]		for(int k=0; k<2; k++) {			ip[k] = imppIn[k].getSlice(roiBoundry);			ip[k].resetMinAndMax();			min[k] = (float)ip[k].getMin();			max[k] = (float)ip[k].getMax();		}		// pixels in ip[0] containing data from imppIn[1]		npix[0] = imppIn[0].getNpixSlice();		if(npix[0]==0) throw new ArithmeticException("Zero pixels in Slice 1");		return;	}	/** @param bins number of bins for quantization of pixel values */	public void setBins(int bins) {		this.bins = bins;		binsSq = bins*bins;		return;	}	/** @param min pixel value for bin value zero */	public void setMin(double[] min) {		for(int k=0; k<2; k++)			this.min[k] = (float)min[k];			return;	}	/** @param max pixel value for bin value bins-1 */	public void setMax(double[] max) {		for(int k=0; k<2; k++)			this.max[k] = (float)max[k];			return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		ip[1] = imppIn[1].getSlice(roiBoundry);		if(ip[0]==null || ip[1]==null)			throw new ArithmeticException("ImageProcessor 2 is null.");		// pixels in ip[1] containing data from imppIn[2]		npix[1] = imppIn[1].getNpixSlice();		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		int h = Math.min(ip[0].getHeight(), ip[1].getHeight());		int w = Math.min(ip[0].getWidth(), ip[1].getWidth());		int[][] row = new int[2][w];		long[][] pdf1DL = new long[2][bins];		long[] pdf2DL = new long[binsSq];		float[] slope = new float[2];		boolean[] fp = new boolean[2];		for(int k=0; k<2; k++) {	// hoist these calculations			slope[k] = (float)(bins-1)/(max[k]-min[k]);			fp[k] = ip[k] instanceof FloatProcessor;		}		// make pdfs		int npixRoi = 0;		for(int j=0; j<h; j++) {			int[] temp = {0, 0};			for(int k=0; k<2; k++) ip[k].getRow(0, j, row[k], w);			for(int i=0; i<w; i++) {				// docs say Black is in, but code says Back is out				if(maskArray!=null &&							maskArray[j*w+i]==(byte)ImageProcessor.BLACK)					continue;				npixRoi++;				for(int k=0; k<2; k++) {					float f;					if(fp[k])						f = Float.intBitsToFloat(row[k][i]);					else						f = (float)row[k][i];					temp[k] = (int) (slope[k]*(f-min[k]));					temp[k] = Math.min(bins-1, Math.max(0, temp[k]));					pdf1DL[k][temp[k]]++;				}				pdf2DL[temp[1]*bins+temp[0]]++;			}		}		if(npixRoi==0) throw new ArithmeticException("Zero pixels in ROI");		float inverseNpixRoi = 1.0F/(float)npixRoi;		float[][] pdf1DF = new float[2][bins];		float[] pdf2DF = new float[binsSq];		for(int i=0; i<bins; i++)			for(int k=0; k<2; k++)				pdf1DF[k][i] = inverseNpixRoi*(float)pdf1DL[k][i];		for(int i=0; i<binsSq; i++)			pdf2DF[i] = inverseNpixRoi*(float)pdf2DL[i];		float mutual = 0F, jentropy = 0F;		for(int j=0; j<bins; j++)			for(int i=0; i<bins; i++) {				float prod01 = pdf1DF[1][j]*pdf1DF[0][i];				if(prod01==0F) continue;				int n = j*bins+i;				if(pdf2DF[n]==0) continue;				mutual += pdf2DF[n]*(float)Math.log(pdf2DF[n]/prod01);				jentropy -= pdf2DF[n]*(float)Math.log(pdf2DF[n]);		}		double r = (double)mutual/(double)jentropy;		return changePenalty*r;	}}	// end of MutualInformationSlice