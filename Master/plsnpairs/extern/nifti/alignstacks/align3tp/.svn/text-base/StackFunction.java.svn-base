package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.awt.Rectangle;import ij.IJ;import ij.ImagePlus;import ij.gui.ImageWindow;import ij.process.ImageProcessor;import ij.WindowManager;/** * This abstract class provides similarity functions for stacks from two * ImagePlusPlus objects as a function of the registration parameters. * Subclasses need to provide: *   protected double eval(double[] xt), the value of the similarity function. * Subclasses may use boundry (null if not defined). * The affine transform optimized by users of this plugin is defined * in the current view, not in the reg space of the ImagePlusPlus. * The relation between the reg space and the current view is: *   regInView = view.transform(reg) *   reg = view.inverse().transform((regInView)) * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 */abstract public class StackFunction extends ImageFunction {	public final static String[] transformName = {		"Translate",		"Scale",		"Translate, scale",		"Rotate",		"Translate, rotate",		"Translate, scale, & rotate",//		"Shear",//		"Translate, scale, & shear",		"Affine"		};	private double whnAvg;	protected Rectangle roiBoundry;	/** Constructor for a volume StackFunction which uses a 3D boundry.	 *	 * @imppIn input ImagePlusPluses	 * @param transform type of transform, e.g. StackFunction.AFFINE_3D	 * @boundry limits for calculation given as two 3D points or null	 */	public StackFunction(ImagePlusPlus[] imppIn, int transform,							int[][] boundry) throws IllegalArgumentException {		if(imppIn.length<2)			throw new IllegalArgumentException("Two stacks required");		if(transform<0 || transform>=transformName.length)			throw new IllegalArgumentException("Illegal transform");		this.imppIn = imppIn;		this.transform = transform;		xt = new double[length()];		for(int i=0; i<xt.length; i++) xt[i] = 0.0;		saveReg();		win = WindowManager.getCurrentWindow();		if(win!=null) win.running = true;		int w = Math.min(imppIn[0].getImp().getWidth(),						imppIn[1].getImp().getWidth()),			h = Math.min(imppIn[0].getImp().getHeight(),						imppIn[1].getImp().getHeight()),			n = Math.min(imppIn[0].getImp().getStackSize(),						imppIn[1].getImp().getStackSize());		whnAvg = (double)(w+h+n-3)/3.0;		// boundry[low corner, high corner][x,y,z]		this.boundry = new int[][] {{0, 0, 0}, {w-1, h-1, n-1}};		if(boundry!=null) {			if(boundry.length<2)				throw new IllegalArgumentException("Illegal boundry");			if(boundry[0].length<3 || boundry[1].length<3)				throw new IllegalArgumentException("Illegal boundry");			for(int i=0; i<3; i++)	// make boundry[0][] low corner				if(boundry[0][i]<=boundry[1][i]) {					this.boundry[0][i] = boundry[0][i];					this.boundry[1][i] = boundry[1][i];				} else {					this.boundry[0][i] = boundry[1][i];					this.boundry[1][i] = boundry[0][i];				}			for(int j=0; j<2; j++) {	// check limits				if(this.boundry[j][0]<0) this.boundry[j][0] = 0;				if(this.boundry[j][1]<0) this.boundry[j][1] = 0;				if(this.boundry[j][2]<0) this.boundry[j][2] = 0;				if(this.boundry[j][0]>=w) this.boundry[j][0] = w-1;				if(this.boundry[j][1]>=h) this.boundry[j][1] = h-1;				if(this.boundry[j][2]>=n) this.boundry[j][2] = n-1;			}		}		// rectangle of boundry in x,y plane		roiBoundry = new Rectangle(this.boundry[0][0], this.boundry[0][1],								this.boundry[1][0]-this.boundry[0][0]+1,								this.boundry[1][1]-this.boundry[0][1]+1);		return;	}	/** Construcor without boundry. */	public StackFunction(ImagePlusPlus[] imppIn, int transform)								throws IllegalArgumentException {		this(imppIn, transform, null);		return;	}	/** Length of xt, which number of arguments to optimize */	protected int length() throws IllegalArgumentException {		switch (transform) {			case 0:	// off[0, 1, 2]				return 3;			case 1:	// m[00, 11, 22]				return 3;			case 2:	// off[0, 1, 2], m[00, 11, 22]				return 6;			case 3:	// theta[0, 1, 2]				return 3;			case 4:	// off[0, 1, 2], theta[0, 1, 2]				return 6;			case 5:	// m[00, 11, 22], off[0, 1, 2], theta[0, 1, 2]				return 9;/*			case 6:	// m[01,10] ???				return 2;			case 7: // m[00, 01, 10, 11], off[0, 1, 2]???				return 6;*/			case 6:	// off[0, 1, 3], m[00...22]				return 12;			default:	// debugging				throw new IllegalArgumentException("Illegal transform");		}	}	/** Evaluation of the function for independent variables, xt */	protected double eval(double[] xt) {		setXt(xt);		return eval();	}	/** Evaluate the function for the two images after the transform has	 * been set.  Defined in subclasses.*/	abstract protected double eval();	/** Sets the registration affine transform in imppIn[1], using	 * the independant variables, xt, after adjusting for	 * the view in imppIn[1].  xt are defined in the current view. */	public void setXt(double[] xt) throws IllegalArgumentException {		this.xt = xt;		double[] off = {0.0, 0.0, 0.0};		Matrix xform = new Matrix(3, 3);	// idenity matrix		double[][] m = xform.m;		EulerAngles ea;		int k = 0;		switch (transform) {			case 0:	// translate				for(int i=0; i<3; i++)					off[i] = xt[k++];				break;			case 1:	// scale				for(int i=0; i<3; i++)					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whnAvg+1.0);				off = scaleOffset(off, m);				break;			case 2:	// translate, scale				for(int i=0; i<3; i++)					off[i] = xt[k++];				for(int i=0; i<3; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whnAvg+1.0);				off = scaleOffset(off, m);				break;			case 3:	// rotate				ea = new EulerAngles(new double[] {2.0*xt[k++]/whnAvg,								2.0*xt[k++]/whnAvg, 2.0*xt[k++]/whnAvg});				xform = ea.getMatrix();				off = centerOffset(off, xform);				break;			case 4:	// translate, rotate				for(int i=0; i<3; i++)					off[i] = xt[k++];				ea = new EulerAngles(new double[] {2.0*xt[k++]/whnAvg,								2.0*xt[k++]/whnAvg, 2.0*xt[k++]/whnAvg});				xform = ea.getMatrix();				off = centerOffset(off, xform);				break;			case 5:	// translate, scale, rotate				for(int i=0; i<3; i++)					off[i] = xt[k++];				for(int i=0; i<3; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whnAvg+1.0);				off = scaleOffset(off, m);				ea = new EulerAngles(new double[] {2.0*xt[k++]/whnAvg,								2.0*xt[k++]/whnAvg, 2.0*xt[k++]/whnAvg});				xform = ea.getMatrix();				off = centerOffset(off, xform);				break;/*			case 6:	// shear				m[1][0] = xt[k++]/whnAvg;				m[0][1] = xt[k++]/whnAvg;				break;			case 7:	// translate, scale, shear				for(int i=0; i<3; i++)					off[i] = xt[k++];				for(int i=0; i<3; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whnAvg+1.0);				off = scaleOffset(off, m);				m[1][0] = xt[k++]/whnAvg;				m[0][1] = xt[k++]/whnAvg;				break;			// translate, scale, rotate, & shear is possible, but these 7			// parameters are not independent since rotate(scale, shear)*/			case 6:	// affine				for(int i=0; i<3; i++)					off[i] = xt[k++];				for(int j=0; j<3; j++)					for(int i=0; i<3; i++)						if(i==j)							m[i][i] = Math.max(MIN_SCALE, xt[k++]/whnAvg+1.0);						else							m[j][i] = xt[k++]/whnAvg;				break;			default:	// debugging				throw new IllegalArgumentException("Illegal transform");		}		// [xform,off].view.initReg <- e.g. defined in view space		// = view.view-1.[xform,off].view.initReg		// = view.newReg, where		// newReg = view-1.[xform,off].view.initReg		imppIn[1].setReg(imppIn[1].getView().inverse().transform(					new Affine(xform, off).transform(					imppIn[1].getView().transform(initReg))));		distanceSq = 0.0;		for(int i=0; i<length(); i++) distanceSq += xt[i]*xt[i];		changePenalty = halfPenaltySq/(distanceSq+halfPenaltySq);		if(showMoves) IJ.write("changePenalty = "+changePenalty);		return;	}	// calculates the offset to make the center of rotation the center	// of the image instead of the upper left corner.	// third Euler angle, Z, is the rotation in the x,y plane	private double[] centerOffset(double[] off, Matrix rot) {		ImagePlus imp = imppIn[1].getImp();		Vector center = new Vector(new double[] {(imp.getWidth()-1)/2.0,						(imp.getHeight()-1)/2.0, (imp.getStackSize()-1)/2.0});		double[] co = center.sub(rot.multiply(center)).value();		for(int i=0; i<3; i++) off[i] += co[i];		return off;	}	// calculates offest to make center of scaling the center of the image.	private double[] scaleOffset(double[] off, double[][] m) {		if(!SCALE_WRT_CENTER) return off;		ImagePlus imp = imppIn[1].getImp();		double[] center = {(imp.getWidth()-1)/2.0, (imp.getHeight()-1)/2.0,							(imp.getStackSize()-1)/2.0};		for(int i=0; i<3; i++) off[i] -= (m[i][i]-1.0)*center[i];		return off;	}}	// end of StackFunction