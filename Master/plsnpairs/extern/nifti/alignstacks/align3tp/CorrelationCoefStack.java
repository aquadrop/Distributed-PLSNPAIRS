package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import java.awt.Rectangle;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the correlation coefficient for stacks from two * ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional boundry. * It works on a 3D stacks using boundry from the parent StackFunction. * The correlation coefficient = *   E((f-mf)*(g-mg)) / sqrt(E((f-mf)^2)*E((g-mg)^2)) *   = E(f*g)-mf*mg / sqrt((E(f*f)-mf*mf)*(E(g*g)-mg*mg)) *   = (sum(f*g)/n-sum(f)/n*sum(g)/n) / *        sqrt((sum(f*f)/n-(sum(f)/n)^2)*(sum(g*g)/n-(sum(g)/n)^2)) *   = (sum(f*g)-sum(f)*sum(g)/n) / *        sqrt((sum(f*f)-sum(f)^2/n)*(sum(g*g)-sum(g)^2/n)) *   where f is the template and g is the second image, mf and mg are the *   respective means. * The correlation coefficient is equal to the cross correlation when *   the means, mf and mg, are zero. * Range -1 to 1. * When positive, the correlation coefficient is multiplied by the * change penalty calculated in StackFunction.  When the overlap is less * than minOverlap, then -distanceSq/halfPenaltySq is returned [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param roi calculation is limited to the region in roi * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class CorrelationCoefStack extends StackFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip0;	private int[] npix = {0, 0};	private int nSlices;	/** Constructor for CrossCorrelation on two stacks without a boundry	 * using default transformation. */	public CorrelationCoefStack(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for CrossCorrelation on two stacks without a boundry. */	public CorrelationCoefStack(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for CrossCorrelation on two stacks with a boundry. 	 * Although the 3D volume for stack0 will require memory, it will be	 * faster to get it only once, and for very large imppIn[0], it is	 * likely that a boundry will be defined so that ip0[n] may be	 * considerably smaller than imppIn[0].   roiBoundry from StackFunction */	public CorrelationCoefStack(ImagePlusPlus[] imppIn, int transform,				int[][] boundryIn)				throws IllegalArgumentException, ArithmeticException {		super(imppIn, transform, boundryIn);		nSlices = boundry[1][2]-boundry[0][2]+1;		ip0 = new ImageProcessor[nSlices];		Affine oldView, view = new Affine();		oldView = imppIn[0].getView();		imppIn[0].setView(view);		for(int slice=0; slice<nSlices; slice++) {			imppIn[0].setViewOffset(-(slice+boundry[0][2]));			ip0[slice] = imppIn[0].getSlice(roiBoundry);			// ip0 should not be null, programming check			if(ip0[slice]==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 1 is null.");			npix[0] += imppIn[0].getNpixSlice();		}		if(npix[0]==0) throw new ArithmeticException("Zero pixels in ROI");		imppIn[0].setView(oldView);		return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		npix[1] = 0;		int npixRoi = 0;		double[] nMean = {0.0, 0.0};		double[] nPower = {0.0, 0.0};		double nCross = 0.0;		Affine oldView, view = new Affine();		oldView = imppIn[1].getView();		imppIn[1].setView(view);		for(int slice=0; slice<nSlices; slice++) {			ImageProcessor ip1;			imppIn[1].setViewOffset(imppIn[1].validViewOffset(												-(slice+boundry[0][2])));			ip1 = imppIn[1].getSlice(roiBoundry);			// ip1 should not be null, programming check			if(ip1==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 2 is null.");			// pixels in ip1 containing data from imppIn[2]			npix[1] += imppIn[1].getNpixSlice();			int h = Math.min(ip0[slice].getHeight(), ip1.getHeight());			int w = Math.min(ip0[slice].getWidth(), ip1.getWidth());			npixRoi += h*w;			int[][] row = new int[2][w];			boolean[] fp = {ip0[slice] instanceof FloatProcessor,	// hoist							ip1 instanceof FloatProcessor};			for(int j=0; j<h; j++) {				double[] temp = {0.0, 0.0};				ip0[slice].getRow(0, j, row[0], w);				ip1.getRow(0, j, row[1], w);				for(int i=0; i<w; i++) {					for(int k=0; k<2; k++) {						if(fp[k])							temp[k] = Float.intBitsToFloat(row[k][i]);						else							temp[k] = (float)row[k][i];						nMean[k] += temp[k];						nPower[k] += temp[k]*temp[k];					}					nCross += temp[0]*temp[1];				}			}		}		imppIn[1].setView(oldView);		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		double mp = Math.sqrt((nPower[0]-nMean[0]*nMean[0]/(double)npixRoi)*								(nPower[1]-nMean[1]*nMean[1]/(double)npixRoi));		if(mp==0.0) return -1.0/(changePenalty+0.001);		double r = (nCross-nMean[0]*nMean[1]/(double)npixRoi)/mp;		return (r>0.0) ? changePenalty*r : r/(changePenalty+0.001);	}}	// end of CorrelationCoefStack