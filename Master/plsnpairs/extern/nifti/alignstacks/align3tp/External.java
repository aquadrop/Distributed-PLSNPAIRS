package extern.nifti.alignstacks.align3tp;import java.awt.*;import java.awt.event.*;import java.awt.image.ColorModel;import java.io.*;import ij.plugin.frame.*;import ij.*;import ij.gui.*;import ij.process.*;import ij.measure.Calibration;import ij.io.*;import extern.nifti.alignstacks.align3tp.Matrix.*;	// import nested top-level classes/** * This class is used by Alignment to provide a method to connect to * an registration program. * imppIn[0].getReg() = z-scaling * imppIn[1].getReg() = registration x z-scaling * output = imppIn[1].getReg().transform(imppIn[0].getReg().inverse()) * imppIn[1].setReg(input.transform(imppIn[0].getReg())) * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 24July2002 * * @see	Align3_TP * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector */class External {	private final static boolean ASK_FILENAMES = true;	private final static String REG_INFO_FILENAME = "Reginfo.txt";	private final static String RETURN_FILENAME = "Newreg.txt";	// null = System.getProperty("line.separator") or "\r\n" or "\r", etc.	private final static String END_OF_LINE = null;	private final static boolean CT_TO_TRANSMISSION = true;	private final static String aboutExternalMessage =		"The external options save and retrieve data for use by an\n" +		"external registration program.  \n" +		"The output info file, "+REG_INFO_FILENAME+",\n" +		"is a text file with the following information on (lines).\n" +		"(1,2) data file path names (2-byte int).\n" +		"(3,4,5) stack 1 and (6,7,8) stack 2 x,y,z dimensions.\n" +		"(9) stack 1 and (10) stack 2 in-plane pixel size.\n" +		"(11) stack 1 and (12) stack 1 slice separation.\n" +		"(13, 14) x, (15,16) y, and (17,18) z min & max ROI.\n" +		"(19-27) m00, m01, ... m22 matrix values, and\n" +		"(28-30) x,y,z offset values, where the coordinates transform\n" +		"according to: stack2 ~= M*Stack1 + offset.";	private final static String[] eDataName = {"Transmission", "CT"};	private String[] eFileName = {"Ct.dat", "Transmission.dat"};	private ImagePlus[] impIn =  {null, null};	private ImagePlusPlus[] imppIn = {null, null};	private ImagePlus[] impSlice =  {null, null};	private int[][] fitRoi;	private Handedness hand;	private String[] eDirectory = {"", ""};	private int[][] eDim = { {128, 128, 128}, {256, 256, 256} };	private double[] ePixSize = {1.0, 1.0}, eSlcSize = {1.0, 1.0};	private boolean switchByteOrder = true;	/**	 * Constructor for Extrnal class.	 *	 * @param impIn the two input ImagePlus images	 * @param imppIn two ImgePlusPlus containing impIn	 * @param impSlice two ImgePlus containing slices from imppIn	 */	External(ImagePlus[] impIn, ImagePlusPlus[] imppIn,				ImagePlus[] impSlice, int[][] fitRoi, Handedness hand) {		this.impIn = impIn;		this.imppIn = imppIn;		this.impSlice = impSlice;		this.fitRoi = fitRoi;		this.hand = hand;		return;	}	void showAboutExternal() {		IJ.showMessage("About Align3_TP", aboutExternalMessage);	}	void setupExternalData(int i) {		if(IJ.getApplet()!=null) return;	// running as applet		String[] filename = {"ct.dat", "transmission.dat"};		eDim[i][0] = impIn[i].getWidth();		eDim[i][1] = impIn[i].getHeight();		eDim[i][2] = impIn[i].getStackSize();		for(int j=0; j<3; j++)			fitRoi[1][j] = Math.min(fitRoi[1][j], eDim[i][j]-1);		FileInfo fi = impIn[0].getOriginalFileInfo();		if(fi!=null)			eDirectory[i] = validDir(fi.directory);		Calibration cal = impIn[i].getCalibration();		if(cal!=null) {			ePixSize[i] = cal.pixelWidth;			eSlcSize[i] = cal.pixelDepth;		}		return;	}	void showExternalData() {		String[][] boundName = { {"xmin", "ymin", "zmin"},								{"xmax", "ymax", "zmax"} };		GenericDialog gd = new GenericDialog("External Registration Data");		String[] s = {null, null};		for(int i=0; i<2; i++)			s[i] = eDataName[i]+" file name: "+eDirectory[i]+eFileName[i]+				"\n"+eDataName[i]+" dimensions = "+				eDim[i][0]+", "+eDim[i][1]+", "+eDim[i][2];		gd.addMessage("Data used by external registration program.\n"+						s[0]+"\n"+s[1]);		for(int i=0; i<2; i++) {			gd.addNumericField(eDataName[i]+" pixel size:", ePixSize[i], 3);			gd.addNumericField(eDataName[i]+" slice thickness:",														eSlcSize[i], 3);		}		for(int j=0; j<3; j++) {			for(int i=0; i<2; i++)				gd.addNumericField(boundName[i][j], fitRoi[i][j], 0);		}		gd.addCheckbox("Switch byte order", switchByteOrder);		gd.showDialog();		for(int i=0; i<2; i++) {			ePixSize[i] = (int) gd.getNextNumber();			eSlcSize[i] = (int) gd.getNextNumber();		}		for(int j=0; j<3; j++)			for(int i=0; i<2; i++)				fitRoi[i][j] = (int) gd.getNextNumber();		switchByteOrder = gd.getNextBoolean();		return;	}	void saveExternalData() {		int index;		String name;		String extension;		SaveDialog sd;		String path;		for(int i=0; i<2; i++) {			if(ASK_FILENAMES) {				index = eFileName[i].indexOf('.');				name = eFileName[i].substring(0, index);				extension = eFileName[i].substring(index);				sd = new SaveDialog(eDataName[i], name, extension);				eDirectory[i] = sd.getDirectory();				eFileName[i] = sd.getFileName();				if(eFileName[i]==null || eFileName[i].equals(""))					continue;			}			ImagePlus imp = imppIn[i].createImagePlus(eDataName[i]);			FileInfo fi = imp.getFileInfo();			if(switchByteOrder)				fi.intelByteOrder = !fi.intelByteOrder;			try {				ImageWriter file = new ImageWriter(fi);				OutputStream out = new BufferedOutputStream(new							FileOutputStream(eDirectory[i]+eFileName[i]));				file.write(out);				out.close();			} catch (IOException e) {				IJ.error("Error writing "+eDirectory[i]+eFileName[i]+": "+e);			}		}		String eol = "";		if(END_OF_LINE==null)			eol = System.getProperty("line.separator");		else			eol = END_OF_LINE;		index = REG_INFO_FILENAME.indexOf('.');		name = REG_INFO_FILENAME.substring(0, index);		extension = REG_INFO_FILENAME.substring(index);		sd = new SaveDialog("Text information file", name, extension);		String fileName = sd.getFileName();		if(fileName==null || fileName.equals("")) return;		try {			DataOutputStream regInfo = new DataOutputStream(new							BufferedOutputStream(new FileOutputStream(							sd.getDirectory()+fileName)));			for(int i=0; i<2; i++)				regInfo.writeBytes(eDirectory[i]+eFileName[i]+eol);			for(int i=0; i<2; i++)				for(int j=0; j<3; j++)					regInfo.writeBytes(eDim[i][j]+eol);			for(int i=0; i<2; i++)				regInfo.writeBytes(ePixSize[i]+eol);			for(int i=0; i<2; i++)				regInfo.writeBytes(eSlcSize[i]+eol);			for(int i=0; i<3; i++)				for(int j=0; j<2; j++)					regInfo.writeBytes(fitRoi[j][i]+eol);			Affine registration = imppIn[1].getReg().transform(									imppIn[0].getReg().inverse());			if(CT_TO_TRANSMISSION)				registration = registration.inverse();			Matrix xform = registration.getMatrix();			for(int i=0; i<3; i++)				for(int j=0; j<3; j++)					regInfo.writeBytes(xform.m[j][i]+eol);			double[] v = registration.getOffset();			for(int i=0; i<3; i++)				regInfo.writeBytes(v[i]+eol);			regInfo.close();		}		catch (FileNotFoundException e) {			IJ.error("File not found: "+e.getMessage());			return;		}		catch (IOException e) {			IJ.error("IOException: "+e.getMessage());			return;		}		return;	}	private String validDir(String dir) {		if(dir==null || dir.equals(""))			dir = Prefs.getString(Prefs.DIR_IMAGE);		if(dir.lastIndexOf(Prefs.getFileSeparator())!=dir.length()-1)			dir = dir+Prefs.getFileSeparator();		return dir;	}	void retrieveExternalData() {		Matrix xform =  new Matrix(3, 3);		double[] v = new double[3];		String fileName = RETURN_FILENAME, directory = eDirectory[0];		if(ASK_FILENAMES) {			OpenDialog od = new OpenDialog("Affine transform input", "");			fileName = od.getFileName();			if(fileName==null || fileName.equals("")) return;			directory = od.getDirectory();		}		try {			BufferedReader in = new BufferedReader(								new FileReader(directory+fileName));			for(int i=0; i<3; i++)				for(int j=0; j<3; j++) {					String s = in.readLine();					if(s==null) {						IJ.error("Premature End of File");						return;					}					xform.m[i][j] = Double.valueOf(s).doubleValue();				}			for(int i=0; i<3; i++) {				String s = in.readLine();				if(s==null) {					IJ.error("Premature End of File");					return;				}				v[i] = Double.valueOf(s).doubleValue();			}			in.close();		} catch (FileNotFoundException e) {			IJ.error("File not found");			return;		} catch (IOException e) {			String msg = e.getMessage();			if (msg.indexOf("EOF")<0) {				IJ.showMessage("Retrieve IOException: ", msg);				return;			}		}		Affine input = new Affine(xform, v);		if(CT_TO_TRANSMISSION)			input = input.inverse();		imppIn[1].setReg(input.transform(imppIn[0].getReg()));		return;	}}	// end of External