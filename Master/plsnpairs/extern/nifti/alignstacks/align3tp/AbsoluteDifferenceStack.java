package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import java.awt.Rectangle;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the sum of the absolute difference for stacks from * two ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional 3D region, boundry. * It works on a 3D stacks using boundry from the parent StackFunction. * The slices are made zero mean prior to calculating the sum of the * absolute differences in order that there will be roughly equal positive * and negative values. * AD = 1 - sum(|(f-fm)-(g-gm)|)/sum(|f-fm|+|g-gm|) *   where fm and gm are the respective means.  Range of AD is [0,1]. * The absolute difference is multiplied by the change penalty calculated * in StackFunction.  When the overlap is less than minOverlap, then * -distanceSq/halfPenaltySq is returned [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param boundryIn calculation is limited to a 3D rectangular region * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class AbsoluteDifferenceStack extends StackFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip0;	private int[] npix = {0, 0};	private int nSlices;	/** Constructor for AbsoluteDifference on two stacks without an ROI using	 * default transformation. */	public AbsoluteDifferenceStack(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for AbsoluteDifference on two stacks without an ROI. */	public AbsoluteDifferenceStack(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for AbsoluteDifference on two stacks with a boundry. */	public AbsoluteDifferenceStack(ImagePlusPlus[] imppIn, int transform,				int[][] boundryIn) 				throws IllegalArgumentException, ArithmeticException {		super(imppIn, transform, boundryIn);		// boundry[low corner, high corner][x,y,z]		nSlices = boundry[1][2]-boundry[0][2]+1;		ip0 = new ImageProcessor[nSlices];		Affine oldView, view = new Affine();		oldView = imppIn[0].getView();		imppIn[0].setView(view);		// gets ip0[] and counts npix[0]		for(int slice=0; slice<nSlices; slice++) {			imppIn[0].setViewOffset(-(slice+boundry[0][2]));			ip0[slice] = imppIn[0].getSlice(roiBoundry);			// ip0 should not be null, programming check			if(ip0[slice]==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 1 is null.");			npix[0] += imppIn[0].getNpixSlice();		}		if(npix[0]==0) throw new ArithmeticException("Zero pixels in ROI");		imppIn[0].setView(oldView);		return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		npix[1] = 0;		int npixRoi = 0;		double[] nMean = {0.0, 0.0};		ImageProcessor[] ip1 = new ImageProcessor[nSlices];		Affine oldView, view = new Affine();		oldView = imppIn[1].getView();		imppIn[1].setView(view);		// get ip1[], count npix[1]		for(int slice=0; slice<nSlices; slice++) {			imppIn[1].setViewOffset(imppIn[1].validViewOffset(												-(slice+boundry[0][2])));			ip1[slice] = imppIn[1].getSlice(roiBoundry);			// ip1[slice] should not be null, programming check			if(ip1[slice]==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 2 is null.");			// pixels in ip1[slice] containing data from imppIn[2]			npix[1] += imppIn[1].getNpixSlice();			int h = Math.min(ip0[slice].getHeight(), ip1[slice].getHeight());			int w = Math.min(ip0[slice].getWidth(),ip1[slice].getWidth());			npixRoi += h*w;			int[][] row = new int[2][w];			boolean[] fp = {ip0[slice] instanceof FloatProcessor,	// hoist							ip1[slice] instanceof FloatProcessor};			for(int j=0; j<h; j++) {				ip0[slice].getRow(0, j, row[0], w);				ip1[slice].getRow(0, j, row[1], w);				for(int i=0; i<w; i++)					for(int k=0; k<2; k++)						if(fp[k])							nMean[k] = Float.intBitsToFloat(row[k][i]);						else							nMean[k] = (float)row[k][i];			}		}		imppIn[1].setView(oldView);		if(npixRoi==0) throw new ArithmeticException("Zero pixels in ROI");		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		double[] mean = {0.0, 0.0};		for(int k=0; k<2; k++) mean[k] = nMean[k]/npixRoi;		double nAbs = 0.0, nAbsDiff =0.0;		for(int slice=0; slice<nSlices; slice++) {			int h = Math.min(ip0[slice].getHeight(), ip1[slice].getHeight());			int w = Math.min(ip0[slice].getWidth(),ip1[slice].getWidth());			int[][] row = new int[2][w];			boolean[] fp = {ip0[slice] instanceof FloatProcessor,	// hoist							ip1[slice] instanceof FloatProcessor};			for(int j=0; j<h; j++) {				double[] temp = {0.0, 0.0};				ip0[slice].getRow(0, j, row[0], w);				ip1[slice].getRow(0, j, row[1], w);				for(int i=0; i<w; i++) {					for(int k=0; k<2; k++) {						if(fp[k])							temp[k] = Float.intBitsToFloat(row[k][i]);						else							temp[k] = (float)row[k][i];						temp[k] -= mean[k];					}					nAbs += Math.abs(temp[0])+Math.abs(temp[1]);					nAbsDiff += Math.abs(temp[0]-temp[1]);				}			}		}		return changePenalty*(1.0-nAbsDiff/nAbs);	}}	// end of AbsoluteDifferenceStack