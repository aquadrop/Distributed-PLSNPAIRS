package extern.nifti.alignstacks.align3tp;import java.awt.*;import java.awt.event.*;import java.io.*;import ij.*;import ij.gui.*;import ij.process.*;import ij.measure.ResultsTable;import ij.text.TextPanel;import ij.measure.Calibration;import extern.nifti.alignstacks.align3tp.Matrix.*;/** * ImageSet holds the data for one stack and the axial, sagital, and * coronal views. * ImagePlus impIn is the input "axial" stack. * static Affine reg is the orientation for all of the images. * ImagePlusPlus imppIn is the stack plus two affine transformations: *   reg is the transformation from the input to the current axial view. *   view is the transformation from the axial view to coronal *     or sagital views and translation to the intersection point. * ImagePlus[] impView are the orthogonal views -- *   called axial, coronal, and sagital views. * static extern.nifti.alignstacks.align3tp.Vector intersection is the point where the *   3 orthogonal views intersect.  it is defined in original stack space, *   e.g. no transformations applied. * Points are upper left corners for screen layout. * Mouser mouse are objects for handling the mouse on each view. * Handedness hand keeps track of the radiological orientation. * * makeView() has "IJ.wait(200);" to prevent intermittent crashes on *   the Macintosh OS9 platform.  This may need to be adjusted on *   other platforms. * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28October2003 * is equal to version 23July2002 plus 8 lines * * @see	Display3_TP * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus * @see	extern.nifti.alignstacks.align3tp.Handedness *		Handedness keeps track of the radiological orientation. * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector *		Note: this class uses both java.util.Vector and extern.nifti.alignstacks.align3tp.Vector. * * @param rightHanded sets class variable giving initial stack handedness * @param d calling object * @param listen sets class variable which include mouse listeners */class ImageSet {	final static int XP_COL = 0, YP_COL = 1, ZP_COL = 2, VALUE_COL = 3,					X_COL = 4, Y_COL = 5, Z_COL = 6;	private static Affine reg = new Affine();	private static Vector intersection = null;	private static boolean rightHanded;	private static boolean listen = true;	private static boolean pickPoint = false;	private static Handedness hand = null;	private static boolean interpolate = false;	private static ResultsTable rt = null;	private static int currentView = DoOption.AXIAL;	// used by Reorient	private final static int LINES = 0, SHORT_LINES = 1,													CROSS = 2;	private final static int SHORT_LINE_LENGTH = 13,							CROSS_LENGTH = 20;	private static boolean crossHairsOn = false;	private static boolean crossHairColor = true;	private static int crossHairType = LINES;	private DoOption d;	private int inID = 0;	private ImagePlus impIn =  null;	private ImagePlusPlus imppIn = null;	private ImagePlus[] impView =  {null, null, null};	private Mouser[] mouse = {null, null, null, null};	private Point[] pView = new Point[3];	private int w, h, size;	ImageSet(boolean rightHanded, DoOption d, boolean listen) {		ImagePlus imp = WindowManager.getCurrentImage();		if(imp!=null)			inID = imp.getID();		this.rightHanded = rightHanded;		if(hand==null)	// first call for class			hand = new Handedness(rightHanded);		this.d = d;		this.listen = listen;		return;	}	// set class variables to default values	static void startOver() {		reg = new Affine();		intersection = null;		hand = null;		interpolate = false;		crossHairsOn = false;		crossHairColor = true;		crossHairType = LINES;		rt = null;		return;	}	/**	 * This method sets up the ImageSet object for one stacks and opens	 * windows for axial, coronal, and sagital views as necessary.	 * Between options the user may close windows etc.  On subsequent	 * calls, setup() verifys that windows have not been changed by user.	 * After closeView(), setup() reopens view windows as necessary.	 *	 * @return false if there is no valid image for the current ID	 */	boolean setup() {		int[] openIDs = WindowManager.getIDList();		if (openIDs==null) {			IJ.error("Open an image stack first.");			return false;		}		if (inID>=0) {			IJ.error("Select an image stack.");			return false;		}		// check that the inID is valid or is still valid		boolean validID = false;		for(int i=0; i<openIDs.length; i++)			if(inID==openIDs[i])				validID = true;		if(!validID) {			IJ.error("ID, "+inID+", is not open.");			return false;		}		if(impIn==null) {	// first call to setup() for this object			impIn=WindowManager.getImage(inID);			if(impIn==null) {	// debugging				IJ.error("getImage(ID) is null.");				return false;			}			w = impIn.getWidth();			h = impIn.getHeight();			size = impIn.getStackSize();			if(size<=1) {				String s = impIn.getTitle();				if(s==null || s=="")					s = "The current image";				IJ.error(s+" is not a stack.");				impIn = null;				return false;			}			imppIn = new ImagePlusPlus(impIn);			layout();			if(intersection==null) {	// first call for this class				double[] p = {(double)(w/2), (double)(h/2), (double)(size/2)};				intersection = new Vector(p);			}			// next 8 lines added 28 October 2003			Calibration cal = impIn.getCalibration();			if(cal.pixelWidth > 0.0 && (cal.pixelHeight != cal.pixelWidth ||										cal.pixelDepth != cal.pixelWidth)) {				double[] scale = {1.0, cal.pixelHeight/cal.pixelWidth,								cal.pixelDepth/cal.pixelWidth};				Affine userInput = new Affine(new ScaleMatrix(scale));				addToOrientation(userInput, false);			}		} else if(impIn.getWindow()==null) {	// user closed window			IJ.error(impIn.getTitle()+" is not open.");			return false;		}		// open or reopen axial, coronal, and sagital slice windows		imppIn.setInterpolate(interpolate);		if(mouse[d.STACK]==null)			mouse[d.STACK] = new Mouser(this, impIn);		for(int i=0; i<3; i++)			if(impView[i]==null || impView[i].getWindow()==null)				makeView(i);		return true;	}	private void layout() {		final int edgex = 30,	// edge of windows					yinc = 0,	// y inc from impIn					xinc = 30;	// x inc from impIn		Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();		Point pImp = impIn.getWindow().getLocation();		Point p = new Point(pImp.x+w+xinc, pImp.y+yinc);		double avail = screen.width-p.x-2*edgex;		int scaledW = w;		// width of axial and coronal = w; width of sagital = h		if((2*w + h)>avail) {			p.x = pImp.x+xinc;			avail = screen.width-p.x-2*edgex;			scaledW = (int)(w*(avail-h)/(double)(2*w));		}		if(scaledW<10) scaledW = 10;		for(int i=0; i<3; i++)			pView[i] = new Point(p.x+i*(edgex+scaledW), p.y);		return;	}	private void makeView(int view) {		setView(view);		ImageProcessor ip = imppIn.getSlice();		setMinAndMax(ip);		addCrossHairs(ip);		impView[view] = new ImagePlus(d.VIEW_NAME[view]+": "+											impIn.getTitle(), ip);		impView[view].show();	// makes window on first call		impView[view].updateAndDraw();		impView[view].getWindow().setLocation(pView[view]);		IJ.wait(200);	// keeps from crashing, I don't know why		mouse[view] = new Mouser(this, impView[view]);		return;	}	private void setMinAndMax(ImageProcessor ip) {		ImageProcessor ipIn = impIn.getProcessor();		double min = ipIn.getMin(), max = ipIn.getMax();		if(ImagePlusPlus.SUBTRACT_MIN_FROM_PIXELS) {			min -= imppIn.getMin();			if(min<0.0) min = 0.0;			max -= imppIn.getMin();			if(max<0.0) max = 0.0;		}		ip.setMinAndMax(min, max);		return;	}	void setView(int view) {		imppIn.setReg(reg);	// all views get this class variable		Matrix m = null;		switch (view) {			case DoOption.AXIAL:			case DoOption.STACK:				m = hand.axial();				break;			case DoOption.CORONAL:				m = hand.coronal();				break;			case DoOption.SAGITAL:				m = hand.sagital();				break;			default:	// debugging				IJ.error("ImageSet.setView: invalid view = "+view);				return;		}		double[] v = m.multiply(reg.transform(intersection)).value();		double[] off = {0.0, 0.0, -v[2]};		imppIn.setView(new Affine(m, off));		double[] addOff = imppIn.centeringData();		double[] vOff = imppIn.getView().getOffset();		for(int j=0; j<2; j++)			vOff[j] += addOff[j];		return;	}	private void addCrossHairs(ImageProcessor ip) {		if(!crossHairsOn) return;		double[] v = imppIn.transform(intersection).value();		int  x = (int) v[0], y = (int) v[1];		int w = ip.getWidth(), h = ip.getHeight(), len;		if(crossHairColor^impIn.isInvertedLut())			ip.setValue(ip.getMin());		else			ip.setValue(ip.getMax());		switch(crossHairType) {			case LINES:				ip.moveTo(0, y);				ip.lineTo(w-1, y);				ip.moveTo(x, 0);				ip.lineTo(x, h-1);				break;			case SHORT_LINES:				len = Math.min(SHORT_LINE_LENGTH, Math.min(w, h));				ip.moveTo(0, y);				ip.lineTo(len-1, y);				ip.moveTo(w-len, y);				ip.lineTo(w-1, y);				ip.moveTo(x, 0);				ip.lineTo(x, len-1);				ip.moveTo(x, h-len);				ip.lineTo(x, h-1);				break;			case CROSS:				len = Math.min(CROSS_LENGTH/2, Math.min(w, h));				ip.moveTo(x-len, y);				ip.lineTo(x+len, y);				ip.moveTo(x, y-len);				ip.lineTo(x, y+len);				break;			default:	// debugging				IJ.error("ImageSet.addCrossHairs: illegal crossHairType = "+								crossHairType);		}		return;	}	// lock impIn and impView[i]	boolean lock() {		if(impIn==null)			return false;		if(!impIn.lock()) {			return false;		}		for(int i=0; i<3; i++)			if(impView[i]!=null)				if(!impView[i].lock())					return false;		return true;	}	// unlock impIn and impView[i]	void unlock() {		if(impIn!=null)			impIn.unlock();		for(int i=0; i<3; i++)			if(impView[i]!=null)				impView[i].unlock();		return;	}	// @return image index if included in ImageSet	int inImageSet(ImagePlus imp) {		if(imp==null)			return d.NONE;		if(imp==impIn)			return d.STACK;		else			for(int i=0; i<3; i++)				if(imp==impView[i])					return i;		return d.NONE;	}	static Affine getReg() {		return reg;	}	// @return ImagePlus for view	ImagePlus getImp(int view) {		switch (view) {			case DoOption.STACK:				return impIn;			case DoOption.AXIAL:			case DoOption.CORONAL:			case DoOption.SAGITAL:				return impView[view];			default:				return null;		}	}	ImagePlusPlus getImpp() {return imppIn;}	static Handedness getHand() {return hand;}	static boolean getInterpolate() {return interpolate;}	static void setInterpolate(boolean interpolate) {		ImageSet.interpolate = interpolate;		return;	}	static int getCurrentView() {return currentView;}	static void setCurrentView(int currentView) {		ImageSet.currentView = currentView;		return;	}	static void setIntersection(Vector intersection) {		ImageSet.intersection = intersection;		return;	}	static void setListen(boolean listen) {		ImageSet.listen = listen;		return;	}	static void setPickPoint(boolean pickPoint) {		ImageSet.pickPoint = pickPoint;		return;	}	static void toggleCrossHairsOn() {		crossHairsOn = !crossHairsOn;		return;	}	static void toggleCrossHairsColor() {		crossHairColor = !crossHairColor;		return;	}	static void incrementCrossHairType() {		crossHairType += 1;		if(crossHairType>CROSS)			crossHairType = LINES;		return;	}	static ResultsTable getRt() {return rt;}	// close axial, coronal, and/or sagital views	// for stack remove mouse listener only	void closeWindow(int view) {		if(view==d.ALL_VIEWS) {			for(int i=0; i<4; i++)				closeWindow(i);			return;		}		if(view<0 || view>3) {	// debugging			IJ.error("ImageSet.closeWindow: invalid view = "+view);			return;		}		if(mouse[view]!=null) mouse[view].removeListeners();		mouse[view] = null;		if(view==d.STACK) return;		if(impView[view]==null) return;		ImageWindow iw = impView[view].getWindow();		if(iw!=null) iw.close();		impView[view].flush();		impView[view] = null;		return;	}	// called from Display.scaleStack().  closes all views except for	//   a view which is in the original stack orientation	void closeScaledWindows() {		for(int i=0; i<3; i++) {			setView(i);			if(imppIn.isAxial()) continue;			closeWindow(i);		}		return;	}	// update axial, coronal, and/or sagital views	void updateWindow(int view) {		if(view==d.ALL_VIEWS) {			for(int i=0; i<3; i++)				updateWindow(i);			return;		}		if(view<0 || view>2) {	// debugging			IJ.error("ImageSet.closeWindow: invalid view = "+view);			return;		}		setView(view);		ImageProcessor ip = imppIn.getSlice();		setMinAndMax(ip);		addCrossHairs(ip);		impView[view].setProcessor(d.VIEW_NAME[view]+": "+											impIn.getTitle(), ip);		return;	}	static void setOrientation(Affine reg) {		ImageSet.reg = reg;		return;	}	// uTransformR = true => U*R	// uTransformR = flase => R*U, e.g. scale stacks	static void addToOrientation(Affine userInput, boolean uTransformR) {		if(uTransformR)			reg = userInput.transform(reg);		else			reg = reg.transform(userInput);		return;	}	static void mirror(String axis) {		hand.flip(reg.getMatrix(), axis);		return;	}	void incrementSlice(double inc) {		if(currentView==d.STACK) return;		setView(currentView);		Vector temp;		double[] v;		v = intersection.value();		temp = new Vector(v);		v = imppIn.transform(temp).value();		switch(currentView) {			case DoOption.AXIAL:				v[2] += inc;				intersection = imppIn.inverse(new Vector(v));				d.updateWindows(d.AXIAL);				break;			case DoOption.CORONAL:				v[2] += inc;				intersection = imppIn.inverse(new Vector(v));				d.updateWindows(d.CORONAL);				break;			case DoOption.SAGITAL:				v[2] += inc;				intersection = imppIn.inverse(new Vector(v));				d.updateWindows(d.SAGITAL);				break;			default:				IJ.error("Display.incrementSlice: invalid view.");				return;		}		return;	}	// called by Mouser	void doMouseAction(int currentX, int currentY) {		int view = inImageSet(WindowManager.getCurrentImage());		if(view<0 || 3<view)	//debugging			IJ.error("Invalid view in doMouseAction = "+view);		setView(view);		Vector temp;		double[] v;		v = intersection.value();		if(view==d.STACK)			v[2] = impIn.getCurrentSlice()-1;		temp = new Vector(v);		v = imppIn.transform(temp).value();		v[0] = currentX;		v[1] = currentY;		intersection = imppIn.inverse(new Vector(v));		currentView = view;		switch(view) {			case DoOption.AXIAL:				d.updateWindows(DoOption.CORONAL);				d.updateWindows(DoOption.SAGITAL);				if(crossHairsOn)					d.updateWindows(DoOption.AXIAL);				break;			case DoOption.CORONAL:				d.updateWindows(DoOption.AXIAL);				d.updateWindows(DoOption.SAGITAL);				if(crossHairsOn)					d.updateWindows(DoOption.CORONAL);				break;			case DoOption.SAGITAL:				d.updateWindows(DoOption.AXIAL);				d.updateWindows(DoOption.CORONAL);				if(crossHairsOn)					d.updateWindows(DoOption.SAGITAL);				break;			case DoOption.STACK:				currentView = DoOption.AXIAL;				d.updateWindows(DoOption.ALL_VIEWS);				break;			default:				IJ.error("Display.doMouseAction: invalid view.");				return;		}		if(pickPoint && view!=DoOption.STACK) {			crossHairsOn = true; crossHairType = CROSS;			for(int i=0; i<3; i++) {				setView(i);				addCrossHairs(impView[i].getProcessor());				impView[i].updateAndDraw();			}			crossHairsOn = false;			if(rt==null) {				rt = new ResultsTable();				TextPanel tp = IJ.getTextPanel();				if(tp!=null) {					tp.selectAll();					tp.clearSelection();				}			}			double[] p = intersection.value();			double value = impView[view].getProcessor().							getPixelValue(currentX, currentY);			rt.incrementCounter();			int counter = rt.getCounter();			rt.setValue(XP_COL, counter-1, (double)currentX);			rt.setValue(YP_COL, counter-1, (double)currentY);			rt.setValue(ZP_COL, counter-1, zPrime(view));			rt.setValue(VALUE_COL, counter-1, value);			rt.setValue(X_COL, counter-1, p[0]);			rt.setValue(Y_COL, counter-1, p[1]);			rt.setValue(Z_COL, counter-1, p[2]);			if(counter==1) rtHeadings();			IJ.write(rt.getRowAsString(counter-1));		}		return;	}	private double zPrime(int view) {		double[] v;		switch(view) {			case DoOption.AXIAL:				setView(DoOption.CORONAL);				v = imppIn.transform(intersection).value();				return v[1];			case DoOption.CORONAL:				setView(DoOption.AXIAL);				v = imppIn.transform(intersection).value();				return v[1];			case DoOption.SAGITAL:				setView(DoOption.AXIAL);				v = imppIn.transform(intersection).value();				return v[0];			default:				IJ.error("Display.zPrime: invalid view.");				return -1.0;		}	}	static void rtHeadings() {		rt.setPrecision(3);		rt.setHeading(XP_COL, "x'");		rt.setHeading(YP_COL, "y'");		rt.setHeading(ZP_COL, "z'");		rt.setHeading(VALUE_COL, "value");		rt.setHeading(X_COL, "x");		rt.setHeading(Y_COL, "y");		rt.setHeading(Z_COL, "z");		IJ.setColumnHeadings(rt.getColumnHeadings());   		return;	}/** * Local class used to implement mouse options. * Implemented as an inner class of ImageSet. * Don't need seperate class, could do this in ImageSet. */class Mouser implements MouseListener, MouseMotionListener {	ImageSet iSet;	ImageCanvas canvas;	Mouser(ImageSet iSet, ImagePlus imp) {		this.iSet = iSet;		canvas = imp.getWindow().getCanvas();		addListeners();		return;	}	void removeListeners() {		canvas.removeMouseListener(this);		canvas.removeMouseMotionListener(this);	}	void addListeners() {		canvas.addMouseListener(this);		canvas.addMouseMotionListener(this);		return;	}	public void mousePressed(MouseEvent e) {		if(!ImageSet.listen) return;		int currentX, currentY;		currentX = canvas.offScreenX(e.getX());		currentY = canvas.offScreenY(e.getY());		iSet.doMouseAction(currentX, currentY);		return;	}	public void mouseReleased(MouseEvent e) {return;}	public void mouseEntered(MouseEvent e) {return;}	public void mouseExited(MouseEvent e) {return;}	public void mouseClicked(MouseEvent e) {return;}	public void mouseMoved(MouseEvent e) {return;}	public void mouseDragged(MouseEvent e) {return;}}	// end of Mouser}	// end of ImageSet