package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.awt.Rectangle;import ij.ImagePlus;import ij.gui.Roi;import ij.gui.ImageWindow;import ij.process.ImageProcessor;import ij.IJ;import ij.WindowManager;/** * This abstract class provides similarity functions for slices from * two ImagePlusPlus objects as a function of registration parameters. * Subclasses need to provide: *   protected double eval(), the value of the similarity function. * Subclasses may use roiBoundry and maskArray. * The current ImageWindow, win, will become false if the user presses * <escape>, or closes the window.  win can be monitored by subclasses * to allow the user to halt long calculations for example with * UserEscapeException. * The affine transform optimized by users of this plugin is defined * in the current view, not in the reg space of the ImagePlusPlus. * The relation between the reg space and the current view is: *   regInView = view.transform(reg) *   reg = view.inverse().transform((regInView)) * getXt() and setXt() get and set the independent variables, xt.  setXt() * also sets the reg Affine transform using the values from xt. * The independent parameters, xt, are converted to the affine transform * parameteres in such a way that a change in distance in xt of 1 represents * about 1 pixel shift in the image.  (Therefore, optimizations can be * set to stop using an arguement which is related to pixel shifts.) * changePenalty can be used to penalize the function if the change is too * large.  Defined in terms of the distance of the change in xt space, * it is halfPenaltySq/(halfPenaltySq+distanceSq), where halfPenalty * is the number of pixels where the penalty is 1/2.  Range [1,0]. * Since there is a minimum scale, MIN_SCALE, such that xt[i] < * -whAvg*(1-MIN_SCALE)the value of the function will not change.  This * constant region has the potential for screwing up an optimization. * A rotaion by theata is equivalent to shearings, Syx = -Sxy = sin(theta), * and scalings Sxx = Syy = cos(theta).  Rotation and shearing in an option * (with scaling) would not be independent. * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector * @see extern.nifti.alignstacks.align3tp.EulerAngles * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 */abstract public class SliceFunction extends ImageFunction {	public final static String[] transformName = {		"Translate",		"Scale",		"Translate, scale",		"Rotate",		"Translate, rotate",		"Translate, scale, & rotate",		"Shear",		"Translate, scale, & shear",		"Affine"		};	private double whAvg;	private Roi roi = null;	protected Rectangle roiBoundry = null;	protected byte[] maskArray = null;	/** Constructor.	 *	 * @param imppIn input ImagePlusPlus(es) with two image stacks	 * @param transform type of transform, e.g. transformName[transform]	 * @param roi limits for calculation using an ImageJ roi, can be null	 */	public SliceFunction(ImagePlusPlus[] imppIn, int transform,				Roi roi) throws IllegalArgumentException {		if(imppIn.length<2)			throw new IllegalArgumentException("Two stacks required");		if(transform<0 || transform>=transformName.length)			throw new IllegalArgumentException("Illegal transform");		this.imppIn = imppIn;		this.transform = transform;		xt = new double[length()];		for(int i=0; i<xt.length; i++) xt[i] = 0.0;		saveReg();		win = WindowManager.getCurrentWindow();		if(win!=null) win.running = true;		int w = imppIn[0].getImp().getWidth(),			h = imppIn[0].getImp().getHeight();		whAvg = (double)(w+h-2)/2.0;		this.roi = roi;		// if not defined setup roiBoundry to prevent getting needless		// values during getSlice operations.		if(roi==null) {			roiBoundry = new Rectangle(w, h);			return;		}		roiBoundry = roi.getBounds();		if(roiBoundry==null || roiBoundry.width<=0 || roiBoundry.height<=0) {			roiBoundry = new Rectangle(w, h);			return;		}		ImageProcessor mask = roi.getMask();		//if(mask!=null) new ImagePlus("Mask", mask).show();		if(mask!=null) maskArray = (byte[]) mask.getPixels();		return;	}	/** Construcor without roi. */	public SliceFunction(ImagePlusPlus[] imppIn, int transform)								throws IllegalArgumentException {		this(imppIn, transform, null);		return;	}	/** Length of xt, which is number of arguments to optimize. */	protected int length() throws IllegalArgumentException {		switch (transform) {			case 0:	// off[0, 1]				return 2;			case 1:	// m[00, 11]				return 2;			case 2:	// off[0, 1], m[00, 11]				return 4;			case 3:	// theta				return 1;			case 4:	// off[0, 1], theta				return 3;			case 5:	// m[00, 11], off[0, 1], theta				return 5;			case 6:	// m[01, 10]				return 2;			case 7: // m[00, 01, 10, 11], off[0, 1]				return 6;			case 8:	// off[0, 1], m[00...11]				return 6;			default:	// debugging				throw new IllegalArgumentException("Illegal transform");		}	}	/** Evaluation of the function for independent variables, xt */	protected double eval(double[] xt) {		setXt(xt);		return eval();	}	/** Evaluate the function for the two images after the transform has	 * been set.  Defined in subclasses.*/	abstract protected double eval();	/** Sets the registration affine transform in imppIn[1], using	 * the independant variables, xt, after adjusting for	 * the view in imppIn[1].  xt are defined in the current view. */	public void setXt(double[] xt) throws IllegalArgumentException {		this.xt = xt;		double[] off = {0.0, 0.0, 0.0};		Matrix xform = new Matrix(3, 3);	// idenity matrix		double[][] m = xform.m;		double angle;		int k = 0;		switch (transform) {			case 0:	// translate				for(int i=0; i<2; i++)					off[i] = xt[k++];				break;			case 1:	// scale				for(int i=0; i<2; i++)					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whAvg+1.0);				off = scaleOffset(off, new double[] {m[0][0], m[1][1]});				break;			case 2:	// translate, scale				for(int i=0; i<2; i++)					off[i] = xt[k++];				for(int i=0; i<2; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whAvg+1.0);				off = scaleOffset(off, new double[] {m[0][0], m[1][1]});				break;			case 3:	// rotate				// sin(x) ~ x for x small				angle = 2.0*xt[k++]/whAvg;	// new angle				xform = new Matrix.RollMatrix(angle);				off = centerOffset(off, xform);				break;			case 4:	// translate, rotate				for(int i=0; i<2; i++)					off[i] = xt[k++];				angle = 2.0*xt[k++]/whAvg;	// new angle				xform = xform.multiply(new Matrix.RollMatrix(angle));				off = centerOffset(off, xform);				break;			case 5:	// translate, scale, rotate				for(int i=0; i<2; i++)					off[i] = xt[k++];				for(int i=0; i<2; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whAvg+1.0);				off = scaleOffset(off, new double[] {m[0][0], m[1][1]});				angle = 2.0*xt[k++]/whAvg;	// new angle				xform = xform.multiply(new Matrix.RollMatrix(angle));				off = centerOffset(off, xform);				break;			case 6:	// shear				m[1][0] = xt[k++]/whAvg;				m[0][1] = xt[k++]/whAvg;				break;			case 7:	// translate, scale, shear				for(int i=0; i<2; i++)					off[i] = xt[k++];				for(int i=0; i<2; i++)	// scales					m[i][i] = Math.max(MIN_SCALE, xt[k++]/whAvg+1.0);				off = scaleOffset(off, new double[] {m[0][0], m[1][1]});				m[1][0] = xt[k++]/whAvg;				m[0][1] = xt[k++]/whAvg;				break;			// translate, scale, rotate, & shear is possible, but these 7			// parameters are not independent since rotate(scale, shear)			case 8:	// affine				for(int i=0; i<2; i++)					off[i] = xt[k++];				for(int j=0; j<2; j++)					for(int i=0; i<2; i++)						if(i==j)							m[i][i] = Math.max(MIN_SCALE, xt[k++]/whAvg+1.0);						else							m[j][i] = xt[k++]/whAvg;				break;			default:	// debugging				throw new IllegalArgumentException("Illegal transform");		}		// [xform,off].view.initReg <- e.g. defined in view space		// = view.view-1.[xform,off].view.initReg		// = view.newReg, where		// newReg = view-1.[xform,off].view.initReg		imppIn[1].setReg(imppIn[1].getView().inverse().transform(					new Affine(xform, off).transform(					imppIn[1].getView().transform(initReg))));		distanceSq = 0.0;		for(int i=0; i<length(); i++) distanceSq += xt[i]*xt[i];		changePenalty = halfPenaltySq/(distanceSq+halfPenaltySq);		if(showMoves) IJ.write("changePenalty = "+changePenalty);		return;	}	// calculates the offset to make the center of rotation the center	// of the image instead of the upper left corner.	// third Euler angle, Z, is the rotation in the x,y plane	private double[] centerOffset(double[] off, Matrix rot) {		ImagePlus imp = imppIn[1].getImp();		Vector center = new Vector(new double[] {(imp.getWidth()-1)/2.0,						(imp.getHeight()-1)/2.0, (imp.getStackSize()-1)/2.0});		double[] co = center.sub(rot.multiply(center)).value();		for(int i=0; i<3; i++) off[i] += co[i];		return off;	}	// calculates offest to make center of scaling the center of the image.	private double[] scaleOffset(double[] off, double[] scale) {		if(!SCALE_WRT_CENTER) return off;		ImagePlus imp = imppIn[1].getImp();		double[] center = {(imp.getWidth()-1)/2.0, (imp.getHeight()-1)/2.0};		for(int i=0; i<2; i++) off[i] -= (scale[i]-1.0)*center[i];		return off;	}}	// end of SliceFunction