package extern.nifti.alignstacks.align3tp;import java.awt.*;import java.awt.event.*;import java.awt.image.ColorModel;import java.io.*;import ij.plugin.frame.*;import ij.*;import ij.gui.*;import ij.process.*;import ij.measure.Calibration;import ij.io.*;import extern.nifti.alignstacks.align3tp.Handedness;	// force compileimport extern.nifti.alignstacks.align3tp.External;	// force compileimport extern.nifti.alignstacks.align3tp.Matrix.*;	// import nested top-level classes/** * This class is the work horse for Align3_TP; it holds the image data * and the methods which implement the Align3_TP options. * Stack1 is manipulated to overlay Stack0. * Axes: x: left-to-right, y: top-to-bottom, z: into display. * ImagePlus[] impIn are selected by the user. * ImagePlusPlus[] imppIn are stacks plus reg and view. * ImagePlus[] impSlice are two slices from impIn used for alignment. * ImagePlus[] impFused is the two slices fused. * ImageProcessors ipxxx are the related ImageProcessors. * Points are upper left corners for screen layout. * * Reg of stack0 is an Affine transform of the data which represents *   scaling (interpolating) in the slice direction.  This transformation *   is also included in reg of stack1.  This transformation could be used *   for other functions in the future. * Reg of stack1 is the registration of stack1 is wrt stack0 (plus scaling *   in the slice direction). * The view slects a display slice. *   View is the same for stack0 and stack1. * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 13November2004 * * @see	Align3_TP * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus * @see	extern.nifti.alignstacks.align3tp.Handedness * @see	extern.nifti.alignstacks.align3tp.External *		Handedness keeps track of the radiological orientation. * @see	extern.nifti.alignstacks.align3tp.History *		History implements undo. * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector */public class Alignment {	// options for OUTPUT_HELP: "ijWindow", "messageWindow", "both"	final static String OUTPUT_HELP = "ijWindow";	final static double MAX_INITIAL_SCALING = 25.0;	final static boolean USER_SELECTS_STACKS = true;	final static int MIN_STACK_SIZE = 1;	final static int AXIAL = 0, CORONAL = 1, SAGITAL = 2, NONE = 3;	final static String aboutMessage =		"Align3_TP aligns two stacks.\n" +		"One Affine transform defines the alignment of the second "+		"stack to the first stack.\n"+		"A second Affine transform defines the current view of the "+		"datasets.\n"+		"The fit region of interest should only be set on " +		"axial, coronal, or\n" +		" sagital views.  It should be set on at least two " +		"orthogonal views.\n" +		"A right handed stack goes from inferior to superior.\n" +		"Install with arguement \"LeftHanded\" for a superior to " +		"inferior stack.\n" +		"Install with arguement \"ExternalRegistration\" to allow\n" +		"saving and retrieving data from an external program.\n" +		"http://www.med.Harvard.edu/JPNM/ij/plugins/extern.nifti.alignstacks.align3tp.html\n"+		"J.A.Parker@IEEE.org\n";	final static String outputHelpMessage =		"Some logical choices for output are\n"+		"	- from \"first stack\", using \"view\" gives:\n"+		"			the first stack in current orientation\n"+		"	- from \"second stack\", using \"alignment\" gives:\n"+		"			an aligned second stack in axial orientation\n"+		"	- from \"second stack\", using \"view & alignment\" gives:\n"+		"			an aligned second stack in current orientation\n"+		"	- from \"fused first & second stacks\","+		" using \"alignment\" gives:\n"+		"			a fused axial stack in axial orientation\n"+		"	- from \"fused first & second stacks\","+		" using \"view & alignment\" gives:\n"+		"			a fused stack in current orientation\n"+		"	- from \"current stack\", using \"alignment\" gives:\n"+		"			the third stack aligned like the second stack\n"+		"Some allowed choices are NOT logical, e.g. from \"first\n"+		"	stack\" using \"alignment\".\n"+		"The \"current stack\" (the regnant or selected"+		" stack) which may be a\n	third stack can also be"+		" aligned.\n"+		"You may select or open a third stack at any point.";		private ImagePlus[] impIn =  {null, null};	private ImageProcessor[] ipIn =  {null, null};	// imppIn, impSlice, hand, currentState, fitRoi used in registration	ImagePlusPlus[] imppIn = {null, null};	ImagePlus[] impSlice =  {null, null};	Handedness hand;	History currentState = null;	int[][] fitRoi = { {0, 0, 0}, {127, 127, 127} };	private int[] inID = {0, 0};	private ImageProcessor[] ipSlice =  {null, null};	private ImagePlus impFused = null;	private ImageProcessor ipFused = null;	private Point[] pIn = new Point[2], pSlice = new Point[2];	private Point pFused = null;	private boolean layedout = false;	private boolean rightHanded = true;	private External external = null;	// alignment variable common block used for alignSlices,	//   for mouse, and for private routines used by these options	// final alignment is keep in ImagePlusPlus.  these variables hold	//   candidate alignment.	// these variables could be a class, but a common block seems simpler	// Order of operation:	// 1 Scale		scale[]	// 2 Rotate		angle	// 3 translate	shift[]	private double[] scale = {1.0 ,1.0, 1.0},					shift = {0.0, 0.0, 0.0},					normWeight = {1.0, 1.0};	// normalize image max	private double angle = 0.0;	private boolean mirrorX = false, mirrorY = false, normValues = true;	private int[] fusedDim = {512, 512};	// common block for alignSlices() and output option	// blitter index and interpolate are remembered between calls	private int blitterIndex = 2;	final int[] blitterCode = {Blitter.ADD, Blitter.AND,				Blitter.AVERAGE, Blitter.DIFFERENCE, Blitter.DIVIDE,				Blitter.MAX, Blitter.MIN, Blitter.MULTIPLY, Blitter.OR,				Blitter.SUBTRACT, Blitter.XOR};	final String[] operation = {"ADD", "AND", "AVERAGE",				"DIFFERENCE", "DIVIDE", "MAX", "MIN",				"MULTIPLY", "OR", "SUBTRACT", "XOR"};	// interpolate is used by registration	boolean interpolate = false;	// common block for mouse options	private String mouseOption = null;	private Mouser mouseFused, mouseSlice0, mouseSlice1;	// used in registration	PlugInFrame myPlugInFrame;	/**	 * Constructor for Alignment class.	 *	 * @param rightHanded right handed stack goes from inferior to superior.	 * @param myPlugInFrame PlugInFrame which hold the buttons	 */	public Alignment(boolean rightHanded, PlugInFrame myPlugInFrame) {		this.rightHanded = rightHanded;		this.myPlugInFrame = myPlugInFrame;	// for end		hand = new Handedness(rightHanded);		external = new External(impIn, imppIn, impSlice, fitRoi, hand);		return;	}	/**	 * performs the operations for one user button push.	 *	 * @param index number of button pushed	 * @return true if the operation has completed	 */	public void doCommand(int index) throws InterruptedException{		switch (index) {			case 0:				startOver(); break;			case 1:				layout(); break;			case 2:				undo(); break;			case 3:				historyInOut(); break;			case 4:				alignSlices(); break;			case 5:				matchROIs(); break;			case 6:				shear("x"); break;			case 7:				shear("y"); break;			case 8:				mouse("translate"); return;			case 9:				mouse("rotate"); return;			case 10:				mouse("resize"); return;			case 11:				endMouse("cancel"); return;			case 12:				resampleLine(); break;			case 13:				axialView(); break;			case 14:				coronalView(); break;			case 15:				sagitalView(); break;			case 16:				scaleStacks(); break;			case 17:				rotate(); break;			case 18:				mirror("x"); break;			case 19:				mirror("y"); break;			case 20:				addToSlice(1.0, true); break;			case 21:				addToSlice(-1.0, true); break;			case 22:				gotoSlice(false); break;			case 23:				gotoSlice(true); break;			case 24:				showRegion(); break;			case 25:				setRegion(); break;			case 26:				new Registration(this, "slice"); break;			case 27:				new Registration(this, "volume"); break;			case 28:				showAbout(); break;			case 29:				outputHelp(); break;			case 30:				makeOutput(); break;			case 31:				printViewReg(); break;		// the following options allow communication to an external		// registration program.  see External class			case 32:				external.showAboutExternal(); break;			case 33:				external.showExternalData(); break;			case 34:				external.saveExternalData(); break;			case 35:				external.retrieveExternalData();				closeSlice(1);				setup();				currentState = new History("Retrieve external affine", 											currentState, imppIn, hand);				break;			default:				break;		}		unlock();		myPlugInFrame.toFront();		myPlugInFrame.requestFocus();		return;	}	public void showAbout() {		IJ.showMessage("About Align3_TP", aboutMessage);	}	/**	 * This method sets up the stacks and slices.  Between options	 *   the user may close windows etc.	 * first call: sets up instance variables and image windows	 * subsequent: verifys that they have not been changed by user	 *	 * @return false if two stacks are not open	 */	public boolean setup() {		// open two ImagePlus stacks.		int[] openID = WindowManager.getIDList();		if (openID==null) {			IJ.error("Two open stacks are required.");			return false;		}		if(USER_SELECTS_STACKS)			if(!askUser(openID)) return false;		else			if(!autoOpen(openID)) return false;		// make ImagePlusPlus and slices		int[] inSlice = {0, 0};		for(int i=0; i<2 ; i++) {			// ImagePlusPlus holds view and reg for impIn			if(imppIn[i]==null) {				imppIn[i] = new ImagePlusPlus(impIn[i]);				inSlice[i] = impIn[i].getCurrentSlice()-1;				if(i==0)					imppIn[0].setViewToSlice(-inSlice[0]);				else {					imppIn[1].setViewToSlice(-inSlice[0]);					imppIn[1].setRegToSlice(inSlice[0]-inSlice[1]);					initialScale();				}				external.setupExternalData(i);			}			// test to see if window was closed by user			if(impSlice[i]!=null && impSlice[i].getWindow().isClosed())				ipSlice[i] = null;			if(ipSlice[i]==null) {				ipSlice[i] = imppIn[i].getSlice();				impSlice[i] = new ImagePlus("Slice from stack "+(i+1),							ipSlice[i]);				impSlice[i].show();				if(layedout) impSlice[i].getWindow().setLocation(pSlice[i]);				ipSlice[i].resetMinAndMax();				impSlice[i].updateAndDraw();			}		}		if(currentState==null)			currentState = new History("Initial State", null, imppIn, hand);		return true;	}	private boolean askUser(int[] openID) {		boolean alreadyOpen = true;		loop: for(int i=0; i<2; i++) {			if(inID[i]!=0)				for(int k=0; k<openID.length; k++)					if(inID[i]==WindowManager.getImage(openID[k]).getID())						continue loop;	// stack still open			alreadyOpen = false;		}		if(alreadyOpen) return true;		closeWindows();	// if both not already closed		for(int i=0; i<2; i++)			imppIn[i] = null;		ImagePlus[] imp = new ImagePlus[openID.length];		int[] stackID = new int[openID.length];		int j=0;		for(int k=0; k<openID.length; k++) {			imp[j] = WindowManager.getImage(openID[k]);			if(imp[j].getStackSize()<MIN_STACK_SIZE)				continue;			stackID[j] = openID[k];			j++;		}		if (j<2) {			IJ.error("Two open stacks are required.");			return false;		}		String[] title = new String[j];		for(int i=0; i<j; i++)			title[i] = imp[i].getTitle();		GenericDialog gd = new GenericDialog("Pick Stacks");		gd.addChoice("Stack 1 (reference):", title, title[0]);		gd.addChoice("Stack 2:", title, title[1]);		gd.showDialog();		if (gd.wasCanceled())			return false;		for(int i=0; i<2; i++) {			inID[i] = stackID[gd.getNextChoiceIndex()];			impIn[i] = WindowManager.getImage(inID[i]);			ipIn[i]= impIn[i].getProcessor();		}		return true;	}	private boolean autoOpen(int[] openID) {		// this loop finds the first two open stacks		loop1: for(int i=0, j=0;  i<2; i++) {			if(inID[i]!=0) {	// previously open				for(int k=0; k<openID.length; k++)					if(inID[i]==WindowManager.getImage(openID[k]).getID())						continue loop1;	// stack still open			}			// otherwise need to open new stack			loop2: for( ; j<openID.length;) {				impIn[i] = WindowManager.getImage(openID[j]);				j++;				if(impIn[i].getStackSize()>=MIN_STACK_SIZE) {					for(int k=0; k<2; k++)						if(impIn[i].getID()==inID[k])							continue loop2;	// already used					ipIn[i]= impIn[i].getProcessor();					inID[i] = impIn[i].getID();					continue loop1;		// valid new stack				}			}			IJ.error("Two open stacks are required.");			return false;		}		return true;	}	// scale width, height, and depth according to calibration	void initialScale() {		Calibration[] cal = {impIn[0].getCalibration(),								impIn[1].getCalibration()};		double[][] c = { {cal[0].pixelWidth, cal[1].pixelWidth},						{cal[0].pixelHeight, cal[1].pixelHeight},						{cal[0].pixelDepth, cal[1].pixelDepth} };		double[] scale = {1.0, 1.0, 1.0};		// if the units have names and the names are different, and		//   the names are recognized, then scale accordingly		double unitScale = 1.0;		String[] unit = {cal[0].getUnit(), cal[1].getUnit()};		for(int j=0; j<2; j++) {			if(unit[j]==null || unit[j].equals(""))				return;	// unit not defined			unit[j] = unit[j].toLowerCase().trim();			if(unit[j].startsWith("pixel"))				return;	// unit not defined		}		if(unit[0]!=unit[1]) {			boolean[] knownUnit = {true, true};			double[] r = {1.0, 1.0};	// unit in mm			for(int j=0; j<2; j++) {				if(unit[j].startsWith("in"))					r[j] = 25.4001;				else if(unit[j].startsWith("mil") ||									unit[j].startsWith("mm"))					r[j] = 1.0;				else if(unit[j].startsWith("cent") ||									unit[j].startsWith("cm"))					r[j] = 10.0;				else if(unit[j].startsWith("meter") ||									unit[j].equals("m"))					r[j] = 1000.0;				else if(unit[j].startsWith("micron"))					r[j] = 1.0/1000.0;				else if(unit[j].startsWith("angstrom"))					r[j] = 1.0e-8;				else					knownUnit[j] = false;			}			if(knownUnit[0] && knownUnit[1])					unitScale = r[1]/r[0];		}		for(int i=0; i<3; i++)			if(c[i][1]!=0.0 && c[i][0]!=0.0) {				double s = unitScale*c[i][1]/c[i][0];				if((1.0/MAX_INITIAL_SCALING)<=s && s<=MAX_INITIAL_SCALING)					scale[i] = s;			}		imppIn[1].addToReg(new Affine(new ScaleMatrix(scale)));		return;	}	void startOver() {		closeWindows();		for(int i=0; i<2; i++) {			inID[i] = 0;			imppIn[i] = null;			Registration.imppS[i] = null;		}		hand = new Handedness(rightHanded);		currentState = null;		Registration.oldSigma = 0.0;		unlock();	// unlock old images		setup();		return;	}	public void closeWindows() {		for(int i=0; i<2; i++)			closeSlice(i);		closeFused();		return;	}	void closeSlice(int i) {		if(impSlice[i]==null) return;		if(impSlice[i].getWindow()!=null)			impSlice[i].getWindow().close();		impSlice[i].flush();		return;	}	void closeFused() {		if(impFused!=null) {			impFused.getWindow().close();			impFused.flush();		}		return;	}	public boolean lock() {		for(int i=0; i<2; i++)			if(impIn[i]==null) return false;		if(!impIn[0].lock()) return false;		if(!impIn[1].lock()){			impIn[0].unlock();			return false;		}		return true;	}	public void unlock() {		for(int i=0; i<2; i++) {			if(impIn[i]!=null) impIn[i].unlock();		}	}	 // Calculates the screen positions for images.	void layout() {		Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();		int xInc, yInc;		final int edgex = 20, edgey = 60;  // edges of windows		yInc = edgey + impIn[0].getHeight();		xInc = edgex + impIn[0].getWidth();		yInc = 3*yInc<screen.height ? yInc : screen.height/3 ;		xInc = 2*xInc<screen.width ? xInc : screen.width/2;		pIn[0] = new Point(0,screen.height-yInc);		pIn[1] = new Point(xInc,screen.height-yInc);		pFused = new Point(0, 0);		//pCine = new Point(xInc, 0);		pSlice[0] = new Point(0, yInc);		pSlice[1] = new Point(xInc, yInc);		for(int i=0; i<2; i++) {			impIn[i].getWindow().setLocation(pIn[i]);			impSlice[i].getWindow().setLocation(pSlice[i]);		}		if(impFused!=null)			impFused.getWindow().setLocation(pFused);		layedout = true;		return;	}	private void initAlignVar() {		for(int i=0; i<3; i++) {			scale[i] = 1.0;			shift[i] = 0.0;		}		for(int i=0; i<2; i++)			fusedDim[i] = 512;		angle = 0.0;		mirrorX = false;		mirrorY = false;		return;	}	// do alignment of slices	void alignSlices() {		initAlignVar();		showFused();		// user input loop		boolean done = false;		while(!done) {			updateFused();			// Get alignment parameters from user			GenericDialog gd = new GenericDialog("Alignment Parameters");			gd.addNumericField("Horizontal scale:", scale[0], 3);			gd.addNumericField("Vertical scale:", scale[1], 3);			gd.addNumericField("Rotate angle:", angle, 1);			gd.addNumericField("Horizontal shift:", shift[0], 0);			gd.addNumericField("Vertical shift:", shift[1], 0);			gd.addNumericField("1st image weight:", imppIn[0].getWeight(), 3);			gd.addNumericField("2nd image weight:", imppIn[1].getWeight(), 3);			gd.addChoice("Blitter Op:", operation, operation[blitterIndex]);			gd.addCheckbox("Mirror horizontal", mirrorX);			gd.addCheckbox("Mirror vertical", mirrorY);			gd.addCheckbox("Interpolate", interpolate);			gd.addCheckbox("Normalize max values", normValues);			gd.addCheckbox("Done with alignment", done);			gd.showDialog();			if(gd.wasCanceled()) break;			if(gd.invalidNumber()) {IJ.error("Invalid number"); continue; }			scale[0] = gd.getNextNumber();			scale[1] = gd.getNextNumber();			angle = gd.getNextNumber();			shift[0] = gd.getNextNumber();			shift[1] = gd.getNextNumber();			if(Math.abs(shift[0])>fusedDim[0] ||						Math.abs(shift[1])>fusedDim[1]) {				IJ.error("Shift is out of range.");				shift[0] = Math.abs(shift[0])>fusedDim[0] ? 0 : shift[0];				shift[1] = Math.abs(shift[1])>fusedDim[1] ? 0 : shift[1];				continue;			}			imppIn[0].setWeight(gd.getNextNumber());			imppIn[1].setWeight(gd.getNextNumber());			blitterIndex = gd.getNextChoiceIndex();			mirrorX = gd.getNextBoolean();			mirrorY = gd.getNextBoolean();			interpolate = gd.getNextBoolean();			normValues = gd.getNextBoolean();			done = gd.getNextBoolean();		}		for(int i=0; i<2; i++)			imppIn[i].setInterpolate(interpolate);		updateAlignment();		currentState = new History("Align slices",										currentState, imppIn, hand);		return;	}	// create a fused window, if necessary	// used by alignSlices() and mouse()	private boolean showFused() {		int w = Math.max(ipSlice[0].getWidth(), ipSlice[1].getWidth()),			h = Math.max(ipSlice[0].getHeight(), ipSlice[1].getHeight());		boolean redisplayed = false;		// if new window is a different size close old window		if(impFused!=null && 				(w!=impFused.getWidth() || h!=impFused.getHeight())) {			impFused.getWindow().close();			impFused.flush();		}		// show Fused, if necessary		if(impFused==null || impFused.getWindow().isClosed()) {			ipFused = ipSlice[0].createProcessor(w, h);			if(ipSlice[1] instanceof FloatProcessor)				ipFused = ipFused.convertToFloat();			impFused = new ImagePlus("Fused", ipFused);			impFused.show();			if(layedout) impFused.getWindow().setLocation(pFused);			redisplayed = true;		}		return redisplayed;	}	// redisplay the fused image	// used by alignSlices() and mouse() and doMouseAction()	private void updateFused() {		ImageProcessor ipTemp1;		ImageProcessor ipTemp2 = ipSlice[0].createProcessor(				Math.max(ipSlice[0].getWidth(), ipSlice[1].getWidth()),				Math.max(ipSlice[0].getHeight(), ipSlice[1].getHeight()));		if(ipSlice[1] instanceof FloatProcessor)			ipTemp2 = ipTemp2.convertToFloat();		setNormValues();		ipFused.setInterpolate(interpolate);		ipSlice[0].setInterpolate(interpolate);		ipSlice[1].setInterpolate(interpolate);		// Scale image 2		ipTemp1 = ipSlice[1].resize((int)(scale[0]*ipSlice[1].getWidth()),					(int)(scale[1]*ipSlice[1].getHeight()));		fusedDim[0] = ipTemp1.getWidth();		fusedDim[1] = ipTemp1.getHeight();		ipTemp1.setInterpolate(interpolate);		// Rotate & multiply image 2		if (angle!=0.0) {ipTemp1.rotate(angle);}		if (normWeight[1]!=1.0 || imppIn[1].getWeight()!=1.0)			ipTemp1.multiply(normWeight[1]*imppIn[1].getWeight());		// Mirror		if(mirrorX) ipTemp1.flipHorizontal();		if(mirrorY) ipTemp1.flipVertical();		// Shift image 2		ipTemp2.setValue(NewImage.FILL_BLACK);		ipTemp2.fill();		ipTemp2.copyBits(ipTemp1, (int)shift[0], (int)shift[1],						Blitter.COPY);		// Multiply image1		ipFused.copyBits(ipSlice[0], 0, 0, Blitter.COPY);		if (normWeight[0]!=1.0 || imppIn[0].getWeight()!=1.0)			ipFused.multiply(normWeight[0]*imppIn[0].getWeight());		// Make fused image		ipFused.copyBits(ipTemp2,  0,  0, blitterCode[blitterIndex]);		ipFused.resetMinAndMax();		impFused.updateAndDraw();		return;	}	// alignment variables to imppIn[1].reg	// used by alignSlices() and endMouse()	private void updateAlignment() {		Matrix scl = new ScaleMatrix(scale),				roll = new RollMatrix(-angle*Math.PI/180.0);		// translate rotation around center to rotation at origin		double[] c = {((double) (fusedDim[0]-1))/2.0,							((double) (fusedDim[1]-1))/2.0, 0.0};		Vector center = (new Vector(c));		Vector center2 = roll.multiply(center);		Vector offset = center.sub(center2).add(new Vector(shift));		Affine userInput = new Affine(roll.multiply(scl), offset.value());		center = center.add(offset);		if(mirrorX) {			Matrix mirror = new MirrorMatrix("x");			center2 = mirror.multiply(center);			Vector offset2 = center.sub(center2);			userInput = new Affine(mirror, offset2.value()).										transform(userInput);		}		if(mirrorY) {			Matrix mirror = new MirrorMatrix("y");			center2 = mirror.multiply(center);			Vector offset2 = center.sub(center2);			userInput = new Affine(mirror, offset2.value()).										transform(userInput);		}		if(userInput.isIdentity()) return;		imppIn[1].addToReg(userInput);		closeSlice(1);		setup();		return;	}	private void setNormValues() {		normWeight[0] = 1.0;		normWeight[1] = 1.0;		if(normValues && imppIn[0].getMax()>0.0 && imppIn[1].getMax()>0.0)			if(imppIn[0].getMax()>imppIn[1].getMax())				normWeight[1] = imppIn[0].getMax()/imppIn[1].getMax();			else				normWeight[0] = imppIn[1].getMax()/imppIn[0].getMax();		return;	}	// resample impIn at a right angle to the slice along a user defined line	void resampleLine() {		Roi roi = null;		for(int i=0; i<2; i++) {			roi = impSlice[i].getRoi();			if(roi!=null)				if(roi.getType()==Roi.LINE) break;		}		if(roi==null) {			IJ.error("Draw a line first.");			return;		} else if(roi.getType()!=Roi.LINE) {			IJ.error("Use the straight line tool.");			return;		}		closeFused();		Line line = (Line) roi;		double x1 = (double)line.x1, y1 = (double)line.y1,				x2 = (double)line.x2, y2 = (double)line.y2;		// theta = direction of line; perpendicular to line is theta-PI/2		double theta = Math.atan2(y2-y1, x2-x1);		// theta1 = direction of (x1, x2), e.g. (r1, theta1)		double theta1 = Math.atan2(y1, x1);		double[] v1 = {(double)x1, (double)y1, 0.0};		// length of perpendicular from origin to line		//   is ||(x1,y1)|| * cos(angle between (x1,y1) and (x2-x1,y2-y1))		double d = new Vector(v1).vectorLength() *						Math.cos(theta-Math.PI/2.0-theta1);		// perpendicular from line to origin		double[] offset = {-d * Math.cos(theta-Math.PI/2.0),						-d * Math.sin(theta-Math.PI/2.0),						0.0};		// move line perpendicularly to origin		Affine userInput1 = new Affine(offset);		// rotate to new orientation		Affine userInput2 = new Affine(hand.flip(							imppIn[0].getView().getMatrix(), theta));		for(int i=0; i<2; i++)			imppIn[i].addToView(userInput2.transform(userInput1));		centerView(false);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Resample along line",											currentState, imppIn, hand);		return;	}	// increase number of slices by increasing the z scale factor in reg	//   for both imppIn	void scaleStacks() {		double[] scale = {1.0, 1.0, 2.0};		GenericDialog gd = new GenericDialog("Interpolate Stack");		gd.addMessage("Scale factor in slice direction for both stacks.\n"+					"Facilitates visualization when the slice-to-slice\n"+					"resolution is less than the in-plane resolution");		gd.addNumericField("Stack scale factor:", scale[2], 1);		gd.showDialog();		if(gd.wasCanceled()) return;		scale[2] = gd.getNextNumber();		if(scale[2]==1.0) return;		Affine userInput = new Affine(new ScaleMatrix(scale));		for(int i=0; i<2; i++)			imppIn[i].setReg(userInput.transform(imppIn[i].getReg()));		centerView(false);		for(int i=0; i<2; i++) {			if(imppIn[i].isAxial()) continue;			closeSlice(i);			}		setup();		currentState = new History("Scale stacks by "+										new Double(scale[2]).toString(),										currentState, imppIn, hand);		return;	}	// change view to axial	void axialView() {		Matrix xform = hand.axial();		closeFused();		for(int i=0; i<2; i++)			imppIn[i].setView(new Affine(xform));		centerView(true);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Axial", currentState, imppIn, hand);		return;	}	// change view to coronal	void coronalView(){		Matrix xform = hand.coronal();		closeFused();		for(int i=0; i<2; i++)			imppIn[i].setView(new Affine(xform));		centerView(true);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Coronal", currentState, imppIn, hand);		return;	}	// change view to sagital	void sagitalView(){		closeFused();		Matrix xform = hand.sagital();		for(int i=0; i<2; i++)			imppIn[i].setView(new Affine(xform));		centerView(true);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Sagital", currentState, imppIn, hand);		return;	}	void rotate() {		double angle = 90.0;		GenericDialog gd = new GenericDialog("Rotate Stacks");		gd.addNumericField("Angle:", angle, 0);		gd.showDialog();		if(gd.wasCanceled()) return;		angle = gd.getNextNumber();		if(angle==0.0) return;		closeFused();		Affine userInput = new Affine(new RollMatrix(angle*Math.PI/180.0));		// add userInput directly to reg, i.e. not corrected for view		for(int i=0; i<2; i++)			imppIn[i].addToView(userInput);		centerView(false);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Rotate by " +									new Double(angle).toString(),									currentState, imppIn, hand);		return;	}	void mirror(String axis) {		closeFused();		Affine mirror = new Affine(hand.flip(								imppIn[0].getView().getMatrix(), axis));		for(int i=0; i<2; i++)			imppIn[i].addToView(mirror);		centerView(false);		for(int i=0; i<2; i++)			closeSlice(i);		setup();		currentState = new History("Mirror " + axis,											currentState, imppIn, hand);		return;	}	private void centerView(boolean threeD) {		double[][] addOff = new double[2][3];		for(int i=0; i<2; i++)			addOff[i] = imppIn[i].centeringData();		double sliceOff;		if(threeD)			sliceOff = Math.abs(addOff[0][2])<Math.abs(addOff[1][2]) ?							addOff[0][2] : addOff[1][2];		else			sliceOff = 0.0;		for(int i=0; i<2; i++) {			double[] vOff = imppIn[i].getView().getOffset();			for(int k=0; k<2; k++)				vOff[k] = vOff[k]+addOff[0][k];			vOff[2] = vOff[2]+sliceOff;		}		return;	}	// Match the ROIs on the two slices	// Line ROI results in a rotation	// Rectangle or oval ROI results in scaling	void matchROIs() {		Roi[] roi = {impSlice[0].getRoi(), impSlice[1].getRoi()};		boolean[] isLine = {false, false};		for(int i=0; i<2; i++) {			if(roi[i]==null) {				IJ.error("Match ROIs: define a ROI on each image\n"+					"Use line tool for rotation,\n"+					"    rectangle or oval tool for size.");				return;			}			if(roi[i].getType()==Roi.LINE)				isLine[i] = true;		}		closeFused();		if(isLine[0] && isLine[1]) {	// both ROIs are lines			Line[] line = new Line[2];			for(int i=0; i<2; i++)				line[i] = (Line) roi[i];			int[] x1 = {line[0].x1, line[1].x1},					x2 = {line[0].x2, line[1].x2},					y1 = {line[0].y1, line[1].y1},					y2 = {line[0].y2, line[1].y2};			double[] theta = new double[2];			for(int i=0; i<2; i++)				theta[i] = Math.atan2(y2[i]-y1[i], x2[i]-x1[i]);			Matrix xform = new RollMatrix(theta[1]-theta[0]);			imppIn[1].addToReg(centered(ipSlice[1], xform));			closeSlice(1);			setup();			currentState = new History("Match straight lines", 										currentState, imppIn, hand);		} else if(!isLine[0] && !isLine[1]) {	// neither is a line			// java.awt.Rectangle			Rectangle[] rect = new Rectangle[2];			double[] x = new double[2], y = new double[2],					h = new double[2], w = new double[2];			for(int i=0; i<2; i++) {				rect[i] = roi[i].getBoundingRect();				x[i] = rect[i].x;				y[i] = rect[i].y;				h[i] = rect[i].height;				w[i] = rect[i].width;			}			double[] scale = {w[0]/w[1], h[0]/h[1], 1.0};			double[] offset = {x[0]-scale[0]*x[1], y[0]-scale[1]*y[1], 0.0};			imppIn[1].addToReg(new Affine(new ScaleMatrix(scale), offset));			closeSlice(1);			setup();			currentState = new History("Match ROIs",										currentState, imppIn, hand);		} else {			IJ.error("Define both ROIs with the line tool for rotation,\n"+					"with rectangle or oval for size change.");		}		return;	}	void shear(String s) {		if(s!="x" && s!="y") {			IJ.error("Programming error:\n"+					"Shear arguement not \"x\" or \"y\"");			return;		}		Roi[] roi = {impSlice[0].getRoi(), impSlice[1].getRoi()};		boolean[] isLine = {false, false};		Line[] line = new Line[2];		double[] x1 = new double[2], x2 = new double[2],				y1 = new double[2], y2 = new double[2];		for(int i=0; i<2; i++)			if(roi[i]!=null && roi[i].getType()==Roi.LINE) {				isLine[i] = true;				line[i] = (Line) roi[i];				x1[i] = (double) line[i].x1;				x2[i] = (double) line[i].x2;				y1[i] = (double) line[i].y1;				y2[i] = (double) line[i].y2;			}		if(!isLine[1]) {			IJ.error("Shear: Use line tool on image2 (or image1 and\n"+					"    image2) to define new vertical (shear\n"+					"    horizontal) or horizontal (shear vertical).");			return;		}		closeFused();		Matrix xform = new Matrix(3, 3);		if(isLine[0] && isLine[1]) {			double[] theta = new double[2];			for(int i=0; i<2; i++)				theta[i] = Math.atan2(y2[i]-y1[i], x2[i]-x1[i]);			if(s=="x")				xform.m[0][1] = Math.tan(theta[1]-theta[0]);			else				xform.m[1][0] = -Math.tan(theta[1]-theta[0]);		} else {			int i;			if(isLine[0])				i=0;			else				i=1;			if(s=="x")				if(y2[i]==y1[i]) {					IJ.error("Can use horizontal line");					return;				} else					xform.m[0][1] = -(x2[i]-x1[i])/(y2[i]-y1[i]);			else				if(x2[i]==x1[i]) {					IJ.error("Can use vertical line");					return;				} else					xform.m[1][0] = -(y2[i]-y1[i])/(x2[i]-x1[i]);		}		imppIn[1].addToReg(centered(ipSlice[1], xform));		closeSlice(1);		setup();		currentState = new History("Shear "+s, currentState, imppIn, hand);		return;	}	// finds the -offset of the center caused by xform	private Affine centered(ImageProcessor ip, Matrix xform) {		double[] c = {((double) (ip.getWidth()-1))/2.0,						((double) (ip.getHeight()-1))/2.0,						0.0};		Vector center = new Vector(c);		Vector center2 = xform.multiply(center);		return new Affine(xform, center.sub(center2).value());	}	// offset is negative wrt inc	void addToSlice(double inc, boolean incriment) {		double[] offset = {0.0, 0.0};		double newOffset;		closeFused();		for(int i=0; i<2; i++)			if(incriment)				offset[i] = imppIn[i].validViewOffset(								imppIn[i].getViewOffset() - inc);			else				offset[i] = imppIn[i].validViewOffset(-inc);		if(inc>0)			newOffset = Math.max(offset[0], offset[1]);		else			newOffset = Math.min(offset[0], offset[1]);		for(int i=0; i<2; i++) {			imppIn[i].setViewOffset(newOffset);			closeSlice(i);		}		setup();		currentState = new History("Goto "+							new Float(1.0-newOffset).toString(), 							currentState, imppIn, hand);		return;	}	// remember choices between calls	int opChoice = 0;	double inc = 5.0;	void gotoSlice(boolean again) {		if(!again) {			String[] op = {"Increment", "Decrement", "Goto"};			GenericDialog gd = new GenericDialog("Slice Selection");			gd.addChoice("Operation: ", op, op[opChoice]);			gd.addNumericField("", inc, 1);			gd.showDialog();			if(gd.wasCanceled()) return;			opChoice = gd.getNextChoiceIndex();			inc = gd.getNextNumber();		}		switch (opChoice) {			case 0:				addToSlice(inc, true); break;			case 1:				addToSlice(-inc, true); break;			case 2:				addToSlice(inc-1, false); break;		}		return;	}	// I think ImageJ shows regions 1 pixel larger than they should be	void showRegion() {		double[][] r = new double[2][3];		double[] v = new double[3];		for(int i=0; i<2; i++) {			for(int j=0; j<3; j++)				v[j] = (double) fitRoi[i][j];			r[i] = imppIn[0].transform(new Vector(v)).value();		}		for(int j=0; j<3; j++)			if(r[0][j]>r[1][j]) {				double temp = r[0][j];				r[0][j] = r[1][j];				r[1][j] = temp;			}		switch (currentView()) {			case AXIAL:			case CORONAL:			case SAGITAL:				break;			default:				IJ.error("View must be axial, coronal, or sagital");				return;		}		impSlice[0].setRoi((int) (r[0][0]+0.5),						(int) (r[0][1]+0.5),						(int) (r[1][0]-r[0][0]+1.5),						(int) (r[1][1]-r[0][1]+1.5) );		return;	}	void setRegion() {		Roi roi = impSlice[0].getRoi();		if(roi==null) {			IJ.error("Define a ROI on slice 1 first.");			return;		}		java.awt.Rectangle rect = roi.getBoundingRect();		double[][] r = new double[2][3];		double[] v = new double[3];		for(int i=0; i<2; i++) {			for(int j=0; j<3; j++)				v[j] = (double) fitRoi[i][j];			r[i] = imppIn[0].transform(new Vector(v)).value();		}		if(r[0][0]<=r[1][0]) {			r[0][0] = (double) rect.x;			r[1][0] = (double) (rect.x+rect.width-1);		} else {			r[1][0] = (double) rect.x;			r[0][0] = (double) (rect.x+rect.width-1);		}		if(r[0][1]<=r[1][1]) {			r[0][1] = (double) rect.y;			r[1][1] = (double) (rect.y+rect.height-1);		} else {			r[1][1] = (double) rect.y;			r[0][1] = (double) (rect.y+rect.height-1);		}		switch(currentView()) {			case AXIAL:			case CORONAL:			case SAGITAL:				break;			default:				IJ.error("View must be axial, coronal, or sagital");				return;		}		for(int i=0; i<2; i++) {			v = imppIn[0].inverse(new Vector(r[i])).value();			for(int j=0; j<3; j++)				fitRoi[i][j] = (int) v[j];		}		return;	}	private int currentView() {		if(imppIn[0].getView().getMatrix().equals(hand.axial()))			return AXIAL;		if(imppIn[0].getView().getMatrix().equals(hand.coronal()))			return CORONAL;		if(imppIn[0].getView().getMatrix().equals(hand.sagital()))			return SAGITAL;		else			return NONE;	}	void outputHelp() {		if(OUTPUT_HELP=="ijWindow" || OUTPUT_HELP=="both")			IJ.write(outputHelpMessage);		if(OUTPUT_HELP=="messageWindow" ||						OUTPUT_HELP=="both")			IJ.showMessage("Output Help", outputHelpMessage);		return;	}	// remember choices between calls	private int stackChoice = 1, orientationChoice = 0, dimensionChoice = 0;	void makeOutput() {		String s;		ImagePlus impCurrent = getCurrentImageTP();		if(impCurrent==null)			s = "";		else			s = impCurrent.getTitle();		String[] stack = {"first stack: "+impIn[0].getTitle(),						"second stack: "+impIn[1].getTitle(),						"current stack: "+s,						"fused first & second stacks",						"fused first & current stacks"};		String[] orientation = {"alignment",						"alignment & z scaling",						"view",						"view & z scaling",						"view & alignment",						"view, alignment, & z scaling"};		String[] outDimensions = {"slice 1.",						"slice 2."};		GenericDialog gd = new GenericDialog("Output Stack");		gd.addMessage("Make a new output stack");		gd.addChoice("from", stack, stack[stackChoice]);		gd.addChoice("using", orientation, orientation[orientationChoice]);		gd.addChoice("with dimensions of",						outDimensions, outDimensions[dimensionChoice]);		gd.addChoice("Blitter Op:", operation, operation[blitterIndex]);		gd.addCheckbox("Interpolate", interpolate);		gd.addCheckbox("Normalize max values", normValues);		gd.showDialog();		if(gd.wasCanceled()) return;		stackChoice = gd.getNextChoiceIndex();		orientationChoice = gd.getNextChoiceIndex();		dimensionChoice = gd.getNextChoiceIndex();		blitterIndex = gd.getNextChoiceIndex();		interpolate = gd.getNextBoolean();		normValues = gd.getNextBoolean();		for(int i=0; i<2; i++)			imppIn[i].setInterpolate(interpolate);		setNormValues();		// set up stacks		// A is stack0; B depends on option		ImagePlus impA = null, impB = null;		boolean fuse = false;		double weightA = 1.0,				weightB = 1.0;		impA = impIn[0];		weightA = normWeight[0]*imppIn[0].getWeight();		switch (stackChoice) {			case 0:		// first stack				impB = impIn[0];				weightB = normWeight[0]*imppIn[0].getWeight();				break;			case 1:		// second stack				impB = impIn[1];				weightB = normWeight[1]*imppIn[1].getWeight();				break;			case 2:		// current or regnant stack				if((impB = impCurrent)==null) {					IJ.error("Select current stack by clicking on it");					return;				}				break;			case 3:		// fused first & second stacks				impB = impIn[1];				fuse = true;				weightB = normWeight[1]*imppIn[1].getWeight();				break;			case 4:		// fused first & current stacks				if((impB = impCurrent)==null) {					IJ.error("Select current stack by clicking on it");					return;				}				fuse = true;				GenericDialog gd2 = new GenericDialog(							"Current, regnant, stack weight");				gd2.addNumericField("Current stack weight:", weightB, 3);				gd2.showDialog();				if(gd2.wasCanceled()) return;				weightB = normWeight[1]*gd2.getNextNumber();				break;			default:	// debugging				IJ.error("No stack choosen.");				return;		}		Affine outRegA = null, outRegB = null;		Matrix xform;		switch (orientationChoice) {			case 0:		// alignment				outRegA = new Affine();				outRegB = imppIn[0].getReg().inverse().							transform(imppIn[1].getReg());				break;			case 1:		// alignment & z scaling				outRegA = new Affine(imppIn[0].getReg());				outRegB = new Affine(imppIn[1].getReg());				break;			case 2:		// view				outRegA = new Affine(imppIn[0].getView());				outRegB = new Affine(imppIn[0].getView());				break;			case 3:		// view & z scaling				outRegA = new Affine(imppIn[0].getView().							transform(imppIn[0].getReg()));				outRegB = new Affine(imppIn[0].getView().							transform(imppIn[0].getReg()));				break;			case 4:		// view & alignment				outRegA = new Affine(imppIn[0].getView());				outRegB = imppIn[1].getView().							transform(imppIn[0].getReg().inverse()).							transform(imppIn[1].getReg());				break;			case 5:		// view, alignment, & z scaling				outRegA = new Affine(imppIn[0].getView().							transform(imppIn[0].getReg()));				outRegB = imppIn[1].getView().							transform(imppIn[1].getReg());				break;			default:	// debugging				IJ.error("No view choosen.");				return;		}		ImageProcessor ipA = impA.getProcessor(),						ipB = impB.getProcessor();		ImagePlusPlus imppA = new ImagePlusPlus(impA),						imppB = new ImagePlusPlus(impB);		imppA.setInterpolate(interpolate);		imppB.setInterpolate(interpolate);		imppA.setReg(outRegA);		imppB.setReg(outRegB);		int[] outD;		switch (dimensionChoice) {			case 0:		// slice 1 dimensions				outD = imppA.getOutD(true); break;			case 1:		// slice 2 dimensions				outD = imppB.getOutD(true); break;			default:	// debugging				IJ.error("No dimension choosen.");				return;		}		if(outD[0]<=0 || outD[1]<=0 || outD[2]<=0) {	// debugging			System.err.println("error: outD[0] = "+outD[0]+								", outD[1] = "+outD[1]+								", outD[2] = "+outD[2]);			return;		}		ColorModel cm = ipB.getColorModel();		ImageStack outStack = new ImageStack(outD[0], outD[1], cm);		double[] minD = imppA.getMinD(true);		double dispMin = Double.MAX_VALUE, dispMax = 0.0;		for(int n=0; n<outD[2]; n++) {			IJ.showStatus(new Integer(n+1).toString()+"/"+						new Integer(outD[2]).toString());			IJ.showProgress((double)n / (double)outD[2]);			double[] offset = {-minD[0], -minD[1], -minD[2]-(double)n};			Affine sliceOffset = new Affine(new Matrix(3,3), offset);			imppB.setView(sliceOffset);			ImageProcessor ipBout = imppB.getSliceData(								ipB.createProcessor(outD[0], outD[1]));			if (weightB!=1.0)				ipBout.multiply(weightB);			if(fuse) {				imppA.setView(sliceOffset);				ImageProcessor ipAout = imppA.getSliceData(									ipA.createProcessor(outD[0], outD[1]));				if (weightA!=1.0)					ipAout.multiply(weightA);				ipBout.copyBits(ipAout,  0,  0, blitterCode[blitterIndex]);			}			ipBout.resetMinAndMax();			dispMin = Math.min(dispMin,ipBout.getMin());			dispMax = Math.max(dispMax,ipBout.getMax());			outStack.addSlice(null, ipBout);		}		IJ.showProgress(1.0);		ImagePlus impOut = new ImagePlus(uniqueName(impB), outStack);		Calibration cal = impB.getCalibration().copy();		double[] scale = {cal.pixelWidth, cal.pixelHeight, cal.pixelDepth};		scale = outRegB.getMatrix().inverse().multiply(								(new Vector(scale))).value();		cal.pixelWidth = scale[0];		cal.pixelHeight = scale[1];		cal.pixelDepth = scale[2];		impOut.setCalibration(cal);		impOut.show();		impOut.getProcessor().setMinAndMax(dispMin, dispMax);		impOut.updateAndDraw();		return;	}	// returns ImagePlus for currently selected image, the regnant image	private ImagePlus getCurrentImageTP() {		ImagePlus imp = WindowManager.getCurrentImage();		if(imp==null) {			IJ.error("Current stack is null.");			return null;		}		for(int i=0; i<2; i++)			if(imp==impSlice[i]) return null;		if(imp==impFused) return null;		if(imp.getStackSize()<MIN_STACK_SIZE) {			IJ.error(imp.getTitle()+" is not a valid stack");			return null;		}		return imp;	}	private String uniqueName(ImagePlus imp) {		String s1 = imp.getTitle()+" aligned", s2 = "";		int[] openID = WindowManager.getIDList();		for(int i=2; i<=1000; i++) {			boolean unique = true;			for(int j=0; j<openID.length; j++)				if((s1+s2).equalsIgnoreCase(WindowManager.									getImage(openID[j]).getTitle())) {					unique = false;					break;				}			if(unique)				return s1+s2;			s2 = " " + new Integer(i).toString();		}		return imp.getTitle()+" aligned 1000+";	}	void printViewReg() {		IJ.write("Stack 1: View\n"+imppIn[0].getView().toString(3)+			"Alignment\n"+imppIn[0].getReg().toString(3)+			"\nStack 2: View\n"+imppIn[1].getView().toString(3)+			"Alignment\n"+imppIn[1].getReg().toString(3));		IJ.showStatus("");		return;	}	void greetings() {		IJ.showMessage("Greetings from Align3_TP");		return;	}	void undo() {		final int HISTORY_LIST_LENGTH = 25;		History h = currentState;		History prior = h.getPrior();		if(prior==null)		// no history			return;		while(true) {			History h2 = h;			int n;			for(n=1; n<HISTORY_LIST_LENGTH; n++) {				if(prior==null) break;				h = prior;				prior = h.getPrior();			}			String[] stateName = new String[n];			History[] state = new History[n];			for(int i=n-1; i>=0; i--) {				stateName[i] = h2.getName();				state[i] = h2;				h2 = h2.getPrior();			}			GenericDialog gd = new GenericDialog("Undo");			gd.addChoice("State: ", stateName, stateName[Math.max(0,n-2)]);			if(prior!=null)				gd.addCheckbox("Prior states", false);			gd.showDialog();			if(gd.wasCanceled()) return;			int index = gd.getNextChoiceIndex();			if(prior!=null)				if(gd.getNextBoolean()) continue;			if(state[index]==currentState) return;			state[index].undo(imppIn, hand);			for(int i=0; i<2; i++)				closeSlice(i);			setup();			currentState = new History("Undo "+stateName[index], 							currentState, imppIn, hand);			return;		}	}	void historyInOut() {		String filename, directory;		String[] choice = {"Restore", "Save"};		GenericDialog gd = new GenericDialog("In/Out");		gd.addChoice("Alignment history: ", choice, choice[1]);		gd.showDialog();		if(gd.wasCanceled()) return;		try {			switch (gd.getNextChoiceIndex()) {				case 0:					OpenDialog od = new OpenDialog("Restore History from: ",													"");					filename = od.getFileName();					if(filename==null || filename.equals("")) return;					directory = od.getDirectory();					ObjectInputStream ois = new ObjectInputStream(							new FileInputStream(directory+filename));					currentState = (History)ois.readObject();					ois.close();					currentState.undo(imppIn, hand);					for(int i=0; i<2; i++)						closeSlice(i);					setup();					break;				case 1:					SaveDialog sd = new SaveDialog("Alignment History: ",							"history", ".ser");					filename = sd.getFileName();					if(filename==null || filename.equals("")) return;					directory = sd.getDirectory();					ObjectOutputStream oos = new ObjectOutputStream(							new FileOutputStream(directory+filename));					oos.writeObject(currentState);					oos.close();					break;				default:					IJ.error("histoyrInOut:  Invalid selection");					return;			}		} catch(IOException e) {			String msg = e.getMessage();			if (msg.indexOf("EOF")<0) {				IJ.showMessage("historyInOut IOException: ", msg);				return;			}		} catch(ClassNotFoundException cnfe) {			IJ.error("historyInOut: ClassNotFoundException");			return;		}		return;	}	void mouse(String option) {		boolean redisplayed = true;		redisplayed = showFused();	// show fused window		if(mouseOption==null) {		// not running			if(option=="rotate")				//Toolbar.getInstance().selectTool(KeyEvent.VK_F4);				// selectTool is no longer supported				Toolbar.getInstance().setTool(Toolbar.FREEROI);			else				//Toolbar.getInstance().selectTool(KeyEvent.VK_F5);				Toolbar.getInstance().setTool(Toolbar.LINE);			initAlignVar();		// initalize the alignment variables			mouseFused = new Mouser(this, impFused);			mouseSlice0 = new Mouser(this, impSlice[0]);			mouseSlice1 = new Mouser(this, impSlice[1]);		}		mouseOption = option;		if(redisplayed)			updateFused();		// update fused window		IJ.showStatus("Drag mouse on slice or fused image.");		return;	}	void doMouseAction(int initialX, int initialY,						int currentX, int currentY) {		if(mouseOption=="translate") {			shift[0] = currentX-initialX;			shift[1] = currentY-initialY;		} else if(mouseOption=="rotate") {			double theta0 = Math.atan2((double)initialY-(fusedDim[1]-1)/2.0,									(double)initialX-(fusedDim[0]-1)/2.0);			double thetaCurrent =						Math.atan2((double)currentY-(fusedDim[1]-1)/2.0,									(double)currentX-(fusedDim[0]-1)/2.0);			angle = (thetaCurrent-theta0)*180.0/Math.PI;		} else if(mouseOption=="resize") {			scale[0] = 1.0 + (double)(currentX-initialX)/(double)initialX;			scale[1] = 1.0 + (double)(currentY-initialY)/(double)initialY;		}		updateFused();		return;	}	void endMouse(String s) {		if(s=="normal") {			updateAlignment();			currentState = new History("Mouse "+mouseOption, 							currentState, imppIn, hand);		}		if(mouseFused!=null) mouseFused.removeListeners();		if(mouseSlice0!=null) mouseSlice0.removeListeners();		if(mouseSlice1!=null) mouseSlice1.removeListeners();		IJ.showStatus("");		mouseOption = null;		mouseFused = null;		// not necessary, but cleans up		mouseSlice0 = null;		// not necessary, but cleans up		mouseSlice1 = null;		// not necessary, but cleans up		if(impFused.getRoi()!=null) impFused.killRoi();		if(impSlice[0].getRoi()!=null) impSlice[0].killRoi();		if(impSlice[1].getRoi()!=null) impSlice[1].killRoi();		unlock();		myPlugInFrame.toFront();		myPlugInFrame.requestFocus();		return;	}/** * Local class used to implement mouse options. * Implemented as an inner class of Alignment. */class Mouser implements MouseListener, MouseMotionListener {	Alignment a;	ImageCanvas canvas;	int initialX, initialY, currentX, currentY;	Mouser(Alignment a, ImagePlus imp) {		this.a = a;		canvas = imp.getWindow().getCanvas();		canvas.addMouseListener(this);		canvas.addMouseMotionListener(this);		return;	}	public void removeListeners() {		canvas.removeMouseListener(this);		canvas.removeMouseMotionListener(this);	}	public void mousePressed(MouseEvent e) {		initialX = canvas.offScreenX(e.getX());		initialY = canvas.offScreenY(e.getY());				return;	}	public void mouseReleased(MouseEvent e) {		a.endMouse("normal");		return;	}	public void mouseEntered(MouseEvent e) {		return;	}	public void mouseExited(MouseEvent e) {		IJ.showStatus("Drag mouse on slice or fused image.");		return;	}	public void mouseClicked(MouseEvent e) {		return;	}	public void mouseMoved(MouseEvent e) {		return;	}	public void mouseDragged(MouseEvent e) {		currentX = canvas.offScreenX(e.getX());		currentY = canvas.offScreenY(e.getY());		a.doMouseAction(initialX, initialY, currentX, currentY);		return;	}}	// end of Mouser}	// end of Alignment