package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the correlation coefficient for slices from two * ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional ROI. * It works on a 2D slices using the roi from an ImageJ ImageProcessor. * The correlation coefficient = *   E((f-mf)*(g-mg)) / sqrt(E((f-mf)^2)*E((g-mg)^2)) *   = E(f*g)-mf*mg / sqrt((E(f*f)-mf*mf)*(E(g*g)-mg*mg)) *   = (sum(f*g)/n-sum(f)/n*sum(g)/n) / *        sqrt((sum(f*f)/n-(sum(f)/n)^2)*(sum(g*g)/n-(sum(g)/n)^2)) *   = (sum(f*g)-sum(f)*sum(g)/n) / *        sqrt((sum(f*f)-sum(f)^2/n)*(sum(g*g)-sum(g)^2/n)) *   where f is the template and g is the second image, mf and mg are the *   respective means. * The correlation coefficient is equal to the cross correlation when *   the means, mf and mg, are zero. * Range -1 to 1. * When positive, the correlation coefficient is multiplied by the * change penalty calculated in SliceFunction.  When the overlap is less * than minOverlap, then -distanceSq/halfPenaltySq is returned [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param roi calculation is limited to the region in roi * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 7September2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class CorrelationCoefSlice extends SliceFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip = new ImageProcessor[2];	private int[] npix = {0, 0};	/** Constructor for CrossCorrelation on two slices without an ROI using	 * default transformation. */	public CorrelationCoefSlice(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for CrossCorrelation on two slices without an ROI. */	public CorrelationCoefSlice(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for CrossCorrelation on two slices with an ROI. */	public CorrelationCoefSlice(ImagePlusPlus[] imppIn, int transform,			Roi roi) throws IllegalArgumentException, ArithmeticException {		super(imppIn, transform, roi);		ip[0] = imppIn[0].getSlice(roiBoundry);		npix[0] = imppIn[0].getNpixSlice();		if(npix[0]==0) throw new ArithmeticException("Zero pixels in ROI");		return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		ip[1] = imppIn[1].getSlice(roiBoundry);		if(ip[0]==null || ip[1]==null)			throw new ArithmeticException("ImageProcessor is null.");		npix[1] = imppIn[1].getNpixSlice();		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		int h = Math.min(ip[0].getHeight(), ip[1].getHeight());		int w = Math.min(ip[0].getWidth(), ip[1].getWidth());		int[][] row = new int[2][w];		int npixRoi = 0;		double[] nMean = {0.0, 0.0};		double[] nPower = {0.0, 0.0};		double nCross = 0.0;		boolean[] fp = {ip[0] instanceof FloatProcessor,	// hoist						ip[1] instanceof FloatProcessor};		for(int j=0; j<h; j++) {			double[] temp = {0.0, 0.0};			for(int k=0; k<2; k++) ip[k].getRow(0, j, row[k], w);			for(int i=0; i<w; i++) {				// docs say Black is in, but code says Back is out				if(maskArray!=null &&							maskArray[j*w+i]==(byte)ImageProcessor.BLACK)					continue;				npixRoi++;				for(int k=0; k<2; k++) {					if(fp[k])						temp[k] = Float.intBitsToFloat(row[k][i]);					else						temp[k] = (float)row[k][i];					nMean[k] += temp[k];					nPower[k] += temp[k]*temp[k];				}				nCross += temp[0]*temp[1];			}		}		if(npixRoi==0) throw new ArithmeticException("Zero pixels in ROI");		double mp = Math.sqrt((nPower[0]-nMean[0]*nMean[0]/(double)npixRoi)*								(nPower[1]-nMean[1]*nMean[1]/(double)npixRoi));		if(mp==0.0) return -1.0/(changePenalty+0.001);		double r = (nCross-nMean[0]*nMean[1]/(double)npixRoi)/mp;		return (r>0.0) ? changePenalty*r : r/(changePenalty+0.001);	}}	// end of CorrelationCoefSlice