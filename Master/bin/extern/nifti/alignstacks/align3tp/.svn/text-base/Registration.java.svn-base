package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import ij.*;import ij.gui.*;/** * This class performs slice or volume registration for Alignment. * It is closely linked with Alignment; it uses many variables defined in * alignment.  It also calls several routines - closeSlice(), closeFused(), * setup(), and unlock(). * * @param align instantiating object * @param sliceOrVol volume registration if string starts with vol * @param Alignment.imppIn two ImagePlusPlus objects to be registered * @param Alignment.interpolate interpolation * @param Alignment.impSlice[0] slice ImagePlus * @param Alignment.fitRoi 3D boundry for fitting * @param Alignment.currentState currentState object * @param Alignment.hand Handedness object * @param Alignment.myPlugInFrame controling frame * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 */public class Registration {	// oldSigma and imppS are reset by startOver in Alignment	// imppS holds smoothed imppIn between instantiations	static double oldSigma = 0.0;	static ImagePlusPlus[] imppS = {null, null};	private Alignment align;	private boolean vol = false;	// remember choices between calls	private static int simFuncChoice = 0, transformChoice = 0,			optimizeChoice = 0, limitChoice = 0, interpMethodChoice = 1,			moves = 10;	private static boolean showMoves = false, plotF = false, minimize = false,			penalize = true, jitter = false;	private static double stoppingC = 0.3, minOverlap = 0.25,			sigma = 0.0; // Math.sqrt(0.5);	private static double parabolicRange = 2.0, parabolicNdata = 15.0,			temptr = 0.2, decreaseStep = 0.3, halfPenalty = 50.0;	private ImageFunction f;	/* Contructor */	public Registration (Alignment align, String sliceOrVol) {		this.align = align;		if (sliceOrVol.startsWith("vol")) vol = true;		if(!doShowDialog()) return;		setupRegistration();		doRegistration();		return;	}	private boolean doShowDialog() {		String[] limitCal;		if(vol)			limitCal = new String[] {"Whole slice", "3D region"};		else			limitCal = new String[] {"Whole slice", "ROI on slice 1"};		String[] simFunc;		simFunc = new String[] {"CC: Correlation coefficient",						"AD: Absolute difference", "MI: Mutual information"};		String[] optimize = {"PW: Powell", "PF: Parabolic fit",						"SA: Simulated Annealing", "NO: No operation"};		String[] interpMethod = {"Nearest neighbor", "Tri-linear",								"MI: Jitter"};		GenericDialog gd = new GenericDialog("Automatic Registration");		gd.addChoice("Limit calculation to:", limitCal,										limitCal[limitChoice]);		gd.addChoice("Similarity function:", simFunc,										simFunc[simFuncChoice]);		if(vol)			gd.addChoice("Transformation:", StackFunction.transformName,						StackFunction.transformName[transformChoice]);		else			gd.addChoice("Transformation:", SliceFunction.transformName,						SliceFunction.transformName[transformChoice]);		gd.addChoice("Optimization algorithm:",										optimize, optimize[optimizeChoice]);		gd.addChoice("Interpolation:", interpMethod,										interpMethod[interpMethodChoice]);		gd.addNumericField("CC: Std for smoothing", sigma, 3);		gd.addNumericField("PW,SA: stopping rule (pixels)", stoppingC, 3);		gd.addNumericField("PW,SA: minimum overlap", minOverlap, 2);		gd.addNumericField("PF: range", parabolicRange, 3);		gd.addNumericField("PF: samples", parabolicNdata, 0);		gd.addNumericField("SA: temperature", temptr, 3);		gd.addNumericField("SA: decrease per step (0,1)", decreaseStep, 3);		gd.addNumericField("SA: moves per step", (double) moves, 0);		//gd.addCheckbox("Minimize function ", minimize);		gd.addCheckbox("Show moves", showMoves);		gd.addCheckbox("Penalize large changes ", penalize);		gd.addNumericField("Half penalty (pixels)", halfPenalty, 3);		gd.addCheckbox("Plot function at optimal point", plotF);		gd.addMessage("<escape> will halt runaway calculation.");		gd.showDialog();		if(gd.wasCanceled()) return false;		limitChoice = gd.getNextChoiceIndex();		simFuncChoice = gd.getNextChoiceIndex();		transformChoice = gd.getNextChoiceIndex();		optimizeChoice = gd.getNextChoiceIndex();		interpMethodChoice = gd.getNextChoiceIndex();		sigma = gd.getNextNumber();		stoppingC = gd.getNextNumber();		minOverlap = gd.getNextNumber();		parabolicRange = gd.getNextNumber();		parabolicNdata = gd.getNextNumber();		temptr = gd.getNextNumber();		decreaseStep = gd.getNextNumber();		moves = (int) gd.getNextNumber();		//minimize = gd.getNextBoolean();		showMoves = gd.getNextBoolean();		penalize = gd.getNextBoolean();		halfPenalty = gd.getNextNumber();		plotF = gd.getNextBoolean();		return true;	}	void setupRegistration() {		switch(interpMethodChoice) {			case 0: align.interpolate = false; jitter = false; break;			case 1: align.interpolate = true; jitter = false; break;			case 2:				align.interpolate = true;				if(simFuncChoice==2)	// mutual information					jitter = true;				else					jitter = false;				break;			default:				IJ.error("Invalid interpolation method");				return;		}		align.imppIn[0].setInterpolate(align.interpolate);		align.imppIn[1].setInterpolate(jitter ? false : align.interpolate);		align.imppIn[1].setJitter(jitter);		Roi roi = null;		int[][] boundry = null;		switch(limitChoice) {			case 0: break;			case 1:				if(vol)					boundry = align.fitRoi;				else					roi = align.impSlice[0].getRoi(); break;			default:				IJ.error("Invalid region of interest");				return;		}		switch(simFuncChoice) {			case 0:				smoothPixels1(sigma);				if(vol)					f = new CorrelationCoefStack(imppS,											transformChoice, boundry);				else					f = new CorrelationCoefSlice(imppS,											transformChoice, roi);				break;			case 1:				if(vol)					f = new AbsoluteDifferenceStack(align.imppIn,												transformChoice, boundry);				else					f = new AbsoluteDifferenceSlice(align.imppIn,												transformChoice, roi);				break;			case 2:				if(vol) {					MutualInformationStack fMI = new 						MutualInformationStack(align.imppIn,											transformChoice, boundry);					fMI.setBins(256);					fMI.setMinOverlap(minOverlap);					f = fMI;				} else {					MutualInformationSlice fMI = new 						MutualInformationSlice(align.imppIn,											transformChoice, roi);					fMI.setBins(256);					fMI.setMinOverlap(minOverlap);					f = fMI;				}				break;			default:				IJ.error("Invalid similarity function choice");				return;		}		f.setMinimize(minimize);		f.setShowMoves(showMoves);		if(penalize)			f.setHalfPenalty(halfPenalty);		else			f.setHalfPenalty(Math.sqrt(Double.MAX_VALUE));	}		// RuntimeException used during debugging to stop optimization		// UserEscapeException is used by user to stop otimization	void doRegistration() {		String s = null;		try{			switch(optimizeChoice) {				case 0:					Brent.setZeps(stoppingC);					Powell pow = null;					pow = new Powell(f, f.getXt(), 0.0);					f.setXt(pow.getP());					if(plotF) f.setP(new Vector(pow.getP()));	// needed?					s = "Iterations = "+pow.getIter()+							", evaluations = "+f.getNEval();					break;				case 1:					ParabolicFit.setNdata((int) parabolicNdata);					ParabolicFit.setRange(parabolicRange);					ParabolicFit pf = new ParabolicFit(f, f.getXt());					f.setXt(pf.getP());					if(plotF) f.setP(new Vector(pf.getP()));	// needed?					s = "Evaluations = "+f.getNEval();					break;				case 2:					if(f.length()<=1) {						IJ.error("This simulated annealing algorithm does\n"+								"not works for a single parameter.\n"+								"Please pick a different alorithm.");						break;					}					SimulatedAnnealing sa = new SimulatedAnnealing(f, null, 																	0.0);					sa.setStopRule(stoppingC);					sa.rule1(temptr, decreaseStep, moves);					f.setXt(sa.getBestPb());					if(plotF) f.setP(new Vector(sa.getBestPb()));					s = "Iterations = "+sa.getIter()+							", evaluations = "+f.getNEval();					break;				case 3:					break;				default:					IJ.error("Invalid maximization algorithm");					return;			}			if(plotF) {				f.saveReg();				f.setShowMoves(false);				int len = f.length();				double[][] xi = new double[len][len];				for(int j=0; j<len; j++)					for(int i=0; i<len; i++)						xi[j][i] = i==j ? 1.0 : 0.0;				f.plot(xi, -5f, 5f, 64);				f.restoreReg();			}		} catch (RuntimeException r) {			align.unlock();			f.restoreReg();			align.myPlugInFrame.toFront();			align.myPlugInFrame.requestFocus();			return;		}		align.closeSlice(1);		align.closeFused();		// makes new slice using jitter; move down two lines to change		align.setup();		align.imppIn[1].setInterpolate(align.interpolate);		align.imppIn[1].setJitter(false);		align.currentState = new History("Slice registration", 				align.currentState, align.imppIn, align.hand);		IJ.showStatus(s);		return;	}	// copy of input align.imppIn to imppS and smooth the pixel array in [1]	// this routine smooths the whole volume	private void smoothPixels1(double sigma) {		if(imppS[0]!=null && sigma==oldSigma) {	// smooth only once			imppS[1].setInterpolate(align.interpolate);			return;		}		oldSigma = sigma;		imppS[0] = align.imppIn[0];	// 0 doesn't need to be smoothed		if(sigma==0.0) {			imppS[1] = align.imppIn[1];			return;	// no smoothing		}		Convolution convol = new Convolution(align.imppIn[1]);		imppS[1] = convol.gaussian(sigma, 5);		return;	}}	// end of Registration