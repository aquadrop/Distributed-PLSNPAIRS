package extern.nifti.alignstacks.align3tp;import java.util.Random;import ij.*;import ij.process.*;import java.awt.image.ColorModel;import java.awt.Rectangle;/** * ImagePlusPlus holds registration and view affine transformations for * an ImagePlus. * It also holds a display min and max for the whole stack, * and it holds a weight multiplier but does not use the weight. * The registration (reg) is meant to define a transformation with *   respect to another ImagePlusPlus object.  The view (view) is mean *   to define a current 2D "display" of the 3D data set.  The reference *   ImagePlusPlus would typically have reg equal to unity.  Both *   reference and registered ImagePlusPluses would typically have the *   same view. * The display slice is view[reg[pixels]], i.e. reg is applied first. * getSlice() returns an ImageProcessor for x,y,0 of view[reg[pixels]]. * Instantiating program is responsible for passing a valid ImagePlus. * Interpolate selects trilinear interpolation. *   The interpolated image goes from (dx, dy, dz) to *   (width+dx, height+dy, size+dz) where dx, dy, and dz are < 1. *   Hence, last row, column, and slice values are used twice. * When interpolate is false, jitter adds +/- 0.5 pixels of noise before *   nearest neighbor interpolation.  This reduces subpixel variations in *   smoothing due to alignments of resampled and original pixels. * This class does not currently handle RGB or byte stacks.  It converts *   RGB to byte then to short.  getSlice() would need to be modified *   to handle 3 values per pixel.  Byte stacks are converted to short. * CT images often ride on a background of about 1000.  This background *   makes fused images non-useful.  Thus, SUBTRACT_MIN_FROM_PIXELS is *   typically set to true.  To output CT style images this paramater *   would need to be made an option, and the calling program would *   need to set it for output. * npixSlice gives the number of valid data pixels in last getSlice() * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 15November2004 * * @see extern.nifti.alignstacks.align3tp.Alignment * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector */public class ImagePlusPlus {	public final static boolean SUBTRACT_MIN_FROM_PIXELS = true;	// OTIMIZE_SPEED should alway be true.  false option is only to show	//   a more easily understandable version of the code.	public final static boolean OPTIMIZE_SPEED = true;	private final static int MAX_DIMENSION = (int) Math.sqrt(											(double) Integer.MAX_VALUE);	private ImagePlus imp;	private Affine view = new Affine(),					reg = new Affine();	private double max = java.lang.Double.MIN_VALUE;	// display max	private double min = java.lang.Double.MAX_VALUE;	// display min	private int npixSlice = 0;	private double weight = 1.0;	// not used within this class	// pixels[slices+1][height*width]	//   extra slice pointer helps with interpolation	//   pixels[size] = pixels[size-1]	private short[][] pixels = null;	// for byte, short, and RBG	private float[][] pixelsF = null;	// for float	private int size, w, h;	private boolean interpolate = false, jitter = false;	private Random rand = null;	// common block for getSlice(), findCorners() centeringData(),	//   getOutD(), getMinD() and getMinDint()	// minD are the coordinates where the image starts along each axis	// maxD are the coordinates where the image ends along each axis	// outD are the output stack dimensions	private double[] minD = new double[3], maxD = new double[3];	private int[] outD = new int[3];	public ImagePlusPlus(ImagePlus imp) {		this.imp = imp;		ImageStack stack = imp.getStack();		size = stack.getSize();		if(size<1) {	// caller error; should not occur			IJ.write("ImagePlusPlus Unhandled error: size = "+size+												" for stack "+stack);			return;		}		w = imp.getWidth();		h = imp.getHeight();		ImageProcessor ip = imp.getProcessor();		if(ip instanceof FloatProcessor)			pixelsF = new float[size+1][];	// extra slice for interpolation		else			pixels = new short[size+1][];	// extra slice for interpolation		for(int n=0; n<size; n++) {			ip = stack.getProcessor(n+1);			if(ip==null) {	// caller error; should not occur				IJ.write("ImagePlusPlus Unhandled error: no slice #"+											(n+1)+" in "+imp);				return;			}			ip = toShortOrFloat(ip);			if(ip instanceof FloatProcessor)				pixelsF[n] = (float[]) ip.getPixels();			else				pixels[n] = (short[]) ip.getPixels();			max = Math.max(max, ip.getMax());			min = Math.min(min, ip.getMin());		}		if(pixels != null)			pixels[size] = pixels[size-1];	// extra slice = last slice		else			pixelsF[size] = pixelsF[size-1];	// extra slice = last slice		if(jitter)			rand = new Random();		return;	}	// returns short of float processors unchanged	// converts byte or RGB to short and scales values to short	private ImageProcessor toShortOrFloat(ImageProcessor ip) {		if(ip instanceof ShortProcessor || ip instanceof FloatProcessor) {			ip.resetMinAndMax();	// make sure min and max are current			return ip;		}		if(ip instanceof ColorProcessor)			ip = ip.convertToByte(false);	// RBG to byte; byte nop		ip = ip.convertToShort(true);		return ip;	}	// returns the number of valid data pixels in last getSlice operation	int getNpixSlice() {return npixSlice;}	// usual method to get the current slice	ImageProcessor getSlice() {return getSlice(null);}	// returns current slice, bounds is a rectagle defining the boundry	// equivalent to ip = getSlice(); ip.setRoi(bounds); ip.crop();	ImageProcessor getSlice(Rectangle bounds) {		ImageProcessor ip = imp.getProcessor();		// special case when affines are unity -> use Wayne's routine		// false disables this option: asymmetry for SUBTRACT_MIN_FROM_PIXELS,		// and for npixSlice.		if(false && view.isIdentity() && reg.isIdentity() &&						bounds==null && !jitter) {			ImageProcessor ipOut = ip.createProcessor(w, h);			ipOut.copyBits(ip, 0, 0, Blitter.COPY);			if(ipOut instanceof ShortProcessor ||						ipOut instanceof FloatProcessor)				ipOut.resetMinAndMax();			else				ipOut = toShortOrFloat(ipOut);			return ipOut;			}		findCorners();	// sets outD		ImageProcessor ipOut;		if(bounds==null)			ipOut = ip.createProcessor(outD[0], outD[1]);		else			ipOut = ip.createProcessor((int) bounds.getWidth(),										(int) bounds.getHeight());		return getSliceData(ipOut, bounds);	}	// usual method except for getSlice	ImageProcessor getSliceData(ImageProcessor ipOut) {		return getSliceData(ipOut, null);	}	// returns current display slice in ipOut	// x[display] = view.transform(reg.transform(x[pixels]))	// x[pixels] = reg.inverse(view.inverse(x[display]))	// where x is meant to be a 3-vector (x, y, z)T & [] -> subscript	ImageProcessor getSliceData(ImageProcessor ipOut, Rectangle bounds) {		int outW = ipOut.getWidth(), outH = ipOut.getHeight();		// width and height are not actually used, but they are set anyway		if(bounds==null)			bounds = new Rectangle(0, 0, outW, outH);		npixSlice = 0;		if(ipOut instanceof FloatProcessor)			return getSliceDataF(ipOut, bounds);		int[] pixelsOut = new int[outW];		ipOut = toShortOrFloat(ipOut);		int iMin = (int) min;	// make sure this conversion is hoisted		if(!OPTIMIZE_SPEED) {			// This loop is logically equivalent to the following (except			//   for interpolation).  it is included for explanation.			//   Compiler should delete this unused code.			for (int j=0; j<outH; j++) {	// rows				for(int i=0; i<outW; i++) {					double[] xDisp = {(double)i+bounds.getX(),									(double)j+bounds.getY(), 0.0};					double[] xPixels = inverse(										new Vector(xDisp)).value();					int x = (int) Math.round(xPixels[0]),						y = (int) Math.round(xPixels[1]),						n = (int) Math.round(xPixels[2]);					if(x<0 || y<0 || n<0 || x>=w || y>=h ||n>=size)						pixelsOut[i] = iMin;					else {						pixelsOut[i] = pixels[n][y*w+x] & 0xffff;						npixSlice++;					}					if(SUBTRACT_MIN_FROM_PIXELS) {						pixelsOut[i] -= iMin;						if(pixelsOut[i] < 0)							pixelsOut[i] = 0;					}				}				ipOut.putRow(0, j, pixelsOut, outW);			}		} else {			Affine regI = reg.inverse(),viewI = view.inverse();			if(regI==null || viewI==null) return null;			Affine a = regI.transform(viewI);			Matrix xform = a.getMatrix();			float[] m = {(float) xform.m[0][0], (float) xform.m[1][0],							(float) xform.m[2][0]};			for(int j=0; j<outH; j++) {	// rows				// display coordinates				double[] xDisp = {bounds.getX(),							(double)j+bounds.getY(), 0.0};				double[] xPixels = a.transform(	// pixel coordinates									new Vector(xDisp)).value();				float[] xPixelsF = {(float) xPixels[0],									(float) xPixels[1], (float) xPixels[2]};				// key loop wrt run time				if(interpolate) {	// trilinear interpolation					// pixel coordinates, xPixelsF, are incremented at the					//   bottom of the loop					for(int i=0; i<outW; i++) {						int x = (int) xPixelsF[0],							y = (int) xPixelsF[1],							n = (int) xPixelsF[2];						if(x<0 || y<0 || n<0 || x>=w || y>=h ||n>=size)							pixelsOut[i] = iMin;						else {							int x1, y1;							x1 = x==w-1 ? x : x+1;	// end of row?							y1 = y==h-1 ? y : y+1;	// end of column?							// end of stack dealt with by pixels[size]							float r0 = Math.max(0F, xPixelsF[0]-(float)x),									r1 = Math.max(0F, xPixelsF[1]-(float)y),									r2 = Math.max(0F, xPixelsF[2]-(float)n);							float r = (								(1F-r2)*									((1F-r1)*										((1F-r0)*pixels[n][y*w+x]										+ r0*pixels[n][y*w+x1])									+ r1*										((1F-r0)*pixels[n][y1*w+x]										+ r0*pixels[n][y1*w+x1]))								+ r2*									((1F-r1)*										((1F-r0)*pixels[n+1][y*w+x]										+ r0*pixels[n+1][y*w+x1])									+ r1*										((1F-r0)*pixels[n+1][y1*w+x]										+ r0*pixels[n+1][y1*w+x1]))							);							if(r>(float)Short.MAX_VALUE)								pixelsOut[i] = Short.MAX_VALUE;							else								pixelsOut[i] = 0xffff & (int)r;							npixSlice++;						}						if(SUBTRACT_MIN_FROM_PIXELS) {							pixelsOut[i] -= iMin;							if(pixelsOut[i] < 0)								pixelsOut[i] = 0;						}						xPixelsF[0] += m[0];						xPixelsF[1] += m[1];						xPixelsF[2] += m[2];					}				} else {	// nearest neighbor					for(int i=0; i<outW; i++) {						int x, y, n;						if(jitter) {							x = (int) Math.round(									xPixelsF[0]+rand.nextFloat()-0.5F);							y = (int) Math.round(									xPixelsF[1]+rand.nextFloat()-0.5F);							n = (int) Math.round(									xPixelsF[2]+rand.nextFloat()-0.5F);						} else {							x = (int) Math.round(xPixelsF[0]);							y = (int) Math.round(xPixelsF[1]);							n = (int) Math.round(xPixelsF[2]);						}						if(x<0 || y<0 || n<0 || x>=w || y>=h ||n>=size)							pixelsOut[i] = iMin;						else {							pixelsOut[i] = pixels[n][y*w+x] & 0xffff;							npixSlice++;						}						if(SUBTRACT_MIN_FROM_PIXELS) {							pixelsOut[i] -= iMin;							if(pixelsOut[i] < 0)								pixelsOut[i] = 0;						}						xPixelsF[0] += m[0];						xPixelsF[1] += m[1];						xPixelsF[2] += m[2];					}				}				ipOut.putRow(0, j, pixelsOut, outW);			}		}		return ipOut;	}	// equivalent to getSliceData, but for FloatProcessor	private ImageProcessor getSliceDataF(ImageProcessor ipOut,												Rectangle bounds) {		int outW = ipOut.getWidth(), outH = ipOut.getHeight();		// Wayne codes floating values using Float.floatToIntBits().		// Thus, the abstract class, ImageProcessor, can put a row of int;		// FloatProcessor translates the int back to a float		//   using Float.intBitsToFloat().		// In this routine pixelsOut are int coded float.		int[] pixelsOut = new int[outW];		float fMin = (float) min;	// hoist this conversion		Affine a = reg.inverse().transform(view.inverse());		Matrix xform = a.getMatrix();		// x, y, z conversion incriments		float[] m = {(float) xform.m[0][0], (float) xform.m[1][0],						(float) xform.m[2][0]};		for(int j=0; j<outH; j++) {	// rows			// display coordinates			double[] xDisp = {bounds.getX(), (double)j+bounds.getY(), 0.0};			double[] xPixels = a.transform(								new Vector(xDisp)).value();			float[] xPixelsF = {(float) xPixels[0],								(float) xPixels[1], (float) xPixels[2]};			// key loop wrt run time			if(interpolate) {	// trilinear interpolation				for(int i=0; i<outW; i++) {					int x = (int) xPixelsF[0],						y = (int) xPixelsF[1],						n = (int) xPixelsF[2];					if(x<0 || y<0 || n<0 || x>=w || y>=h ||n>=size)						pixelsOut[i] = Float.floatToIntBits(fMin);					else {						int x1, y1;						x1 = x==w-1 ? x : x+1;	// end of row?						y1 = y==h-1 ? y : y+1;	// end of column?						// end of stack dealt with by pixelsF[size]						float r0 = Math.max(0F, xPixelsF[0]-(float)x),								r1 = Math.max(0F, xPixelsF[1]-(float)y),								r2 = Math.max(0F, xPixelsF[2]-(float)n);						float r = (							(1F-r2)*								((1F-r1)*									((1F-r0)*pixelsF[n][y*w+x]									+ r0*pixelsF[n][y*w+x1])								+ r1*									((1F-r0)*pixelsF[n][y1*w+x]									+ r0*pixelsF[n][y1*w+x1]))							+ r2*								((1F-r1)*									((1F-r0)*pixelsF[n+1][y*w+x]									+ r0*pixelsF[n+1][y*w+x1])								+ r1*									((1F-r0)*pixelsF[n+1][y1*w+x]									+ r0*pixelsF[n+1][y1*w+x1]))						);						pixelsOut[i] = Float.floatToIntBits(r);						npixSlice++;					}					if(SUBTRACT_MIN_FROM_PIXELS) {						float r = Float.intBitsToFloat(pixelsOut[i]) - fMin;						if(r<0F) r = 0F;						pixelsOut[i] = Float.floatToIntBits(r);					}					xPixelsF[0] += m[0];					xPixelsF[1] += m[1];					xPixelsF[2] += m[2];				}			} else {	// nearest neighbor				for(int i=0; i<outW; i++) {					int x, y, n;					if(jitter) {						x = (int) Math.round(								xPixelsF[0]+rand.nextFloat()-0.5F);						y = (int) Math.round(								xPixelsF[1]+rand.nextFloat()-0.5F);						n = (int) Math.round(								xPixelsF[2]+rand.nextFloat()-0.5F);					} else {						x = (int) Math.round(xPixelsF[0]);						y = (int) Math.round(xPixelsF[1]);						n = (int) Math.round(xPixelsF[2]);					}					if(x<0 || y<0 || n<0 || x>=w || y>=h ||n>=size)						pixelsOut[i] = 0;					else {						pixelsOut[i] = Float.floatToIntBits(pixelsF[n][y*w+x]);						npixSlice++;					}					if(SUBTRACT_MIN_FROM_PIXELS) {						float r = Float.intBitsToFloat(pixelsOut[i]) - fMin;						if(r<0F) r = 0F;						pixelsOut[i] = Float.floatToIntBits(r);					}					xPixelsF[0] += m[0];					xPixelsF[1] += m[1];					xPixelsF[2] += m[2];				}			}			ipOut.putRow(0, j, pixelsOut, outW);		}		return ipOut;	}	// dimensions for axes	int[] getOutD(boolean update) {		if(update)			findCorners();		return outD;	}	// minimum values for axes	double[] getMinD(boolean update) {		if(update)			findCorners();		return minD;	}	// minimum values for axes as integer	int[] getMinDint(boolean update) {		if(update)			findCorners();		int[] minDint = new int[3];		for(int i=0; i<3; i++)			minDint[i] = (int) Math.round(minD[i]);		return minDint;	}	// returns offset increments to upper left corner of center image	double[] centeringData() {		findCorners();		double[] addOff = new double[3];		addOff[0] = -minD[0];		//x		addOff[1] = -minD[1];		//y		addOff[2] = -((maxD[2]-minD[2])/2 + minD[2]);	// z		return addOff;	}	// sets up minD, maxD, and outD 	// minD and maxD are the min and max values for the axes	//   they are the average of the four smallest or largest corners	//   e.g. midway on the three lines leading to the extreme corner	private void findCorners() {		double[][] corners = {{(double) w-1, (double) h-1, (double) size-1},						{0.0, (double) h-1, (double) size-1},						{(double) w-1, 0.0, (double) size-1},						{0.0, 0.0, (double) size-1},						{(double) w-1, (double) h-1, 0.0},						{0.0, (double) h-1, 0.0},						{(double) w-1, 0.0, 0.0},						{0.0, 0.0, 0.0} };		double[][] cXform = new double[3][8];		double[] c;		// find the values of the corners in the output space		for(int i=0; i<8; i++) {			c = transform(new Vector(corners[i])).value();			for(int k=0; k<3; k++)				cXform[k][i] = c[k];		}		// the minimum and maximum of the output axes are the average of		//   the midpoints of the three edges going to the extreme corner		for(int k=0; k<3; k++) {			quickSort(cXform[k], 0, 7);			minD[k] = (3.0*cXform[k][0] + cXform[k][1] +						cXform[k][2]+ cXform[k][3])/6.0;			maxD[k] = (3.0*cXform[k][7] + cXform[k][6] +						cXform[k][5] + cXform[k][4])/6.0;		}		// x and y start at 0		for(int k=0; k<2; k++)			outD[k] = 1 + (int) Math.round(maxD[k]);		outD[2] = 1 + (int) Math.round(maxD[2]-minD[2]);		for(int k=0; k<3; k++)			outD[k] = Math.max(1, Math.min(MAX_DIMENSION ,outD[k]));		return;	}	private void quickSort(double[] list, int start, int end) {		if(end<=start) return;		if(end-start==1 && list[start]<list[end]) return;		double test = (list[start]+list[end])/2.0;		int i=start, j=end;		for(; i<j;) {			if(list[i]<=test)				i++;			else if(list[j]>test)				j--;			else {				double temp=list[i];				list[i] = list[j];				list[j] = temp;				i++;			}		}		quickSort(list, start, i-1);		quickSort(list, i, end);		return;	}	boolean isAxial(){		Matrix xform = view.transform(reg).getMatrix();		if(xform.m[0][2]==0.0 && xform.m[1][2]==0.0 &&			xform.m[2][0]==0.0 && xform.m[2][1]==0.0)			return true;		else			return false;	}	boolean isCoronal(){		Matrix xform = view.transform(reg).getMatrix();		if(xform.m[0][1]==0.0 && xform.m[1][1]==0.0 &&			xform.m[2][0]==0.0 && xform.m[2][2]==0.0)			return true;		else			return false;	}	boolean isSagital(){		Matrix xform = view.transform(reg).getMatrix();		if(xform.m[0][0]==0.0 && xform.m[1][0]==0.0 &&			xform.m[2][1]==0.0 && xform.m[2][2]==0.0)			return true;		else			return false;	}	Vector transform(Vector in) {		return view.transform(reg.transform(in));	}	Vector inverse(Vector in) {		return reg.inverse(view.inverse(in));	}	// slice is negatvie wrt offset	double validViewOffset(double testOffset) {		findCorners();	// sets minD and maxD		double[] offset = view.getOffset();		double slice = -(testOffset - offset[2]);		if(minD[2]<slice)			if(slice<maxD[2])				return testOffset;			else				return offset[2]-maxD[2];		else			return offset[2]-minD[2];	}	// makes an ImagePlus from the pixel array, i.e. short or float data.	ImagePlus createImagePlus(String title) {		ImageStack is = new ImageStack(w, h);		for(int i=0; i<size; i++)			is.addSlice("Slice"+new Integer(i).toString(),									createImageProcessor(i));		return new ImagePlus(title, is);	}	// makes and ImageProcessor (ShortProcessor) for slice from	//   the pixel array, i.e. does not use reg or view.	ImageProcessor createImageProcessor(int slice) {		java.awt.image.ColorModel cm = imp.getProcessor().getColorModel();		if(pixels!=null)			return new ShortProcessor(w, h, pixels[slice], cm);		else			return new FloatProcessor(w, h, pixelsF[slice], cm);	}	double getViewOffset() {		double[] offset = view.getOffset();		return offset[2];	}	void setViewOffset(double slice) {		double[] offset = view.getOffset();		offset[2] = slice;		return;	}	void addToView(Affine userInput) {		view = userInput.transform(view);		return;	}	// userInput is defined in view space.	// userInput is transformed to reg space only by view.getMatrix(),	//   (veiw.getOffset() is not used in translation.)	// transformed input is used to transform reg.	// userInput.transform(view.transform(reg)	//   = U*V*R = V*U'*R	//   => U*V = V*U'	//   => V[-1]*U*V = V[-1]*V*U' = U'	void addToReg(Affine userInput) {		reg = view.inverse().						transform(userInput).						transform(view).						transform(reg);		return;	}	boolean setViewToSlice(int slice) {		if(slice>=size)			return false;		double[] offset = {0.0, 0.0, (double) slice};		view = new Affine(offset);		return true;	}	boolean setRegToSlice(int slice) {		if(slice>=size)			return false;		double[] offset = {0.0, 0.0, (double) slice};		reg = new Affine(offset);		return true;	}	void setReg(Affine reg) {		this.reg = reg;		return;	}	public void setView(Affine view) {		this.view = view;		return;	}	void setWeight(double weight) {		this.weight = weight;		return;	}	void setInterpolate(boolean interpolate) {		this.interpolate = interpolate;		return;	}	void setJitter(boolean jitter) {		this.jitter = jitter;		if(jitter && rand==null)			rand = new Random();		return;	}	ImagePlus getImp() {return imp;}	Affine getReg() {return reg;}	Affine getView() {return view;}	double getWeight() {return weight;}	double getMax() {return max;}	double getMin() {return min;}	double getSliceMin() {return SUBTRACT_MIN_FROM_PIXELS ? 0.0 : min;}	double getSliceMax() {return SUBTRACT_MIN_FROM_PIXELS ? max-min : max;}	boolean getInterpolate() {return interpolate;}	Object getPixels() {		if(pixels != null)			return (Object)pixels;		else			return (Object)pixelsF;	}}