package extern.nifti.alignstacks.align3tp;/** * This class represents a set of Euler angles, (x y z), which are rotations * around the respective axes, where the final rotation M is X.Y.Z where X, Y, * and Z are matrices representing the respective rotations.  x is pitch;  * See http://www.flipcode.com/documents/matrfaq.html.  On my computer, * in Documents/Downloaded/MatrixandQuaternionFAQ.txt. * * @param axis rotation axis, normal to the plane of rotation * @param angle angle of rotation in radians * @param in rotation matrix to be xformed into a quaternion * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 4September2002 */public class EulerAngles {	// (EAx, EAy, EAz)	private double[] ea = new double[3];	/** constructor from a set of angles (x y z) */	public EulerAngles(double[] ea) {		for(int i=0; i<3; i++) this.ea[i] = clamp(ea[i]);		return;	}	/** constructor from a rotation matrix */	public EulerAngles(Matrix in) throws IllegalArgumentException {		this(in.m);		return;	}	/** constructor from an array */	public EulerAngles(double[][] m) throws IllegalArgumentException {		if(m.length!=3)			throw new IllegalArgumentException("Incompatible dimensions");		for(int j=0; j<3; j++)			if(m[j].length!=3)				throw new IllegalArgumentException("Incompatible dimensions");		ea[1] = Math.asin(m[0][2]);		double cos1 = Math.cos(ea[1]);		if(Math.abs(cos1)<0.005*Math.PI/180.0) {	// Gimball lock?			ea[0] = 0.0;			ea[2] = Math.atan2(m[1][0], m[1][1]);		} else {			ea[0] = Math.atan2(-m[1][2]/cos1, m[2][2]/cos1);			ea[2] = Math.atan2(-m[0][1]/cos1, m[0][0]/cos1);		}		for(int i=0; i<3; i++) ea[i] = clamp(ea[i]);		return;	}	/** retuns Euler angles x, y, z */	public double[] getAngles() {return ea;}	/** returns a rotation matrix equivalent to this */	public Matrix getMatrix() {return new Matrix(getArray());}	/** returns a rotation array equivalent to this */	public double[][] getArray() {		double[][] m = new double[3][3];		double[] sin = {Math.sin(ea[0]), Math.sin(ea[1]), Math.sin(ea[2])},				cos = {Math.cos(ea[0]), Math.cos(ea[1]), Math.cos(ea[2])};		m[0][0] = cos[1]*cos[2];		m[0][1] = -cos[1]*sin[2];		m[0][2] = -sin[1];		m[1][0] = -sin[0]*sin[1]*cos[2]+cos[0]*sin[2];		m[1][1] = sin[0]*sin[1]*sin[2]+cos[0]*cos[2];		m[1][2] = -sin[0]*cos[1];		m[2][0] = cos[0]*sin[1]*cos[2]+sin[0]*sin[2];		m[2][1] = -cos[0]*sin[1]*sin[2]+sin[0]*cos[2];		m[2][2] = cos[0]*cos[1];		return m;	}	/** return a quaternion equivalent to this */	public Quaternion getQuaternion() {		Quaternion[] q = new Quaternion[3];		q[0] = new Quaternion(new double[] {1.0, 0.0, 0.0}, ea[0]);		q[1] = new Quaternion(new double[] {0.0, 1.0, 0.0}, ea[1]);		q[2] = new Quaternion(new double[] {0.0, 0.0, 1.0}, ea[2]);		return q[0].multiply(q[1]).multiply(q[2]);	}	private double clamp(double v) {		v = Math.IEEEremainder(v, 2.0*Math.PI);		return v>=0 ? v : 2.0*Math.PI+v;	}}	// end of EulerAngles