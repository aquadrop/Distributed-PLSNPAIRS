package extern.nifti.alignstacks.align3tp;import java.awt.image.ColorModel;import java.awt.event.*;import ij.plugin.frame.*;import ij.*;import ij.gui.*;import ij.process.*;import ij.io.FileSaver;import ij.plugin.MeasurementsWriter;import ij.measure.ResultsTable;import ij.text.TextPanel;import extern.nifti.alignstacks.align3tp.Handedness;	// force compileimport extern.nifti.alignstacks.align3tp.ImageSet;	// force compileimport extern.nifti.alignstacks.align3tp.Matrix.*;	// imported nested top-level classes/** * This class implements the Reorient3_TP options; it holds an ImageSet * for each stack. * Axes: x: left-to-right, y: top-to-bottom, z: into display. * isv is a vector of ImageSet(s), each of which hold a stack and the *   axial, coronal, and sagital views. * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 23July2002 * * @see	Reorient3_TP * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus * @see	extern.nifti.alignstacks.align3tp.Handedness *		Handedness keeps track of the radiological orientation. * @see	extern.nifti.alignstacks.align3tp.Affine * @see	extern.nifti.alignstacks.align3tp.Matrix * @see	extern.nifti.alignstacks.align3tp.Vector *		Note: this class uses both java.util.Vector and extern.nifti.alignstacks.align3tp.Vector. */public class Reorient extends DoOption {	private final static String aboutMessage =		"Reorient3_TP provides an orthogonal view stack display,\n" +		"which may be used to reorient the stacks.\n" +		"At startup or for the \"New stack\" or \"Additional stack\"\n" +		"options, the currently selected stack is used.\n" +		"Coronal and sagital views are define with respect to the axial\n" +		"view using the usual Radiology standard.\n" +		"A right handed stack goes from inferior to superior.\n" +		"Install with arguement \"LefttHanded\" for a superior to " +		"inferior stack\n" +		"http://www.med.Harvard.edu/JPNM/ij/plugins/Display3TP.html\n"+		"J.A.Parker@IEEE.org\n";	ImageSet is = null;	/**	 * Constructor for Reorient class.	 *	 * @param rightHanded right handed stack goes from inferior to superior.	 * @param myPlugInFrame main PlugInFrame which hold the buttons	 */	public Reorient(boolean rightHanded, PlugInFrame myPlugInFrame) {		this.rightHanded = rightHanded;		this.myPlugInFrame = myPlugInFrame;	// for end of doCommand		ImageSet.startOver();		return;	}	public void showAbout() {		IJ.showMessage("About Reorient3_TP", aboutMessage);		return;	}	/**	 * This method sets up the views.  Between options the user may	 *   close windows etc.	 *	 * @return false if no stacks are open	 */	public boolean setup() {		// if no ImageSets defined, try to add current stack		if(isv.size()<=0)			isv.addElement((Object) new ImageSet(rightHanded, this, false));		for(int i=0; i<isv.size(); )			if(((ImageSet) isv.elementAt(i)).setup())				i++;			else				isv.removeElementAt(i);		if(isv.size() > 0)			return true;		else			return false;	}	/**	 * Perform the operation for one user button push.	 *	 * @param index number of button pushed	 */	public void doCommand(int index) throws InterruptedException{		switch (index) {			case 0:				startOver(); break;			case 1:				additionalStack(); break;			case 2:				scaleStacks(); break;			case 3:				showAbout(); break;			case 4:				resampleLine(); break;			case 5:				mirror("x"); break;			case 6:				mirror("y"); break;			case 7:				mirror("z"); break;			case 8:				rotate("axial");				ImageSet.setCurrentView(DoOption.AXIAL);				break;			case 9:				rotate("coronal");				ImageSet.setCurrentView(DoOption.CORONAL);				break;			case 10:				rotate("sagital");				ImageSet.setCurrentView(DoOption.SAGITAL);				break;			case 11:				viewFromPicks(); break;			case 12:				ImageSet.setPickPoint(false);				ImageSet.setListen(true);				break;			case 13:				ImageSet.setPickPoint(true);				ImageSet.setListen(true);				break;			case 14:				ImageSet.setListen(false);				break;			case 15:				ImageSet.toggleCrossHairsColor();				updateWindows(ALL_VIEWS);				setup();				break;			case 16:				new MeasurementsWriter().run(""); break;			case 17:				picks("delete all"); break;			case 18:				picks("delete last"); break;			case 19:				picks("refresh"); break;			case 20:				incrementSlice(1.0); break;			case 21:				incrementSlice(-1.0); break;			case 22:				nextView(); break;			case 23:				greetings(); break;			case 24:				rotateLine("vertical"); break;			case 25:				rotateLine("horizontal"); break;			case 26:				output(); break;			case 27:				printViewReg(); break;			default:				break;		}		unlock();		myPlugInFrame.toFront();		myPlugInFrame.requestFocus();		return;	}	// resample impIn at a right angle to the slice along a user defined line	void resampleLine() {		Line line = getLine();	// sets is and view		if(line==null) return;		Handedness hand = is.getHand();		Matrix viewMatrix = null;		switch (ImageSet.getCurrentView()) {			case STACK:			case AXIAL:				viewMatrix = hand.axial();				break;			case CORONAL:				viewMatrix = hand.coronal();				break;			case SAGITAL:				viewMatrix = hand.sagital();				break;			default:				IJ.error("resample: invalid view = "+										ImageSet.getCurrentView());				break;		}		Affine toView = new Affine(viewMatrix);		double x1 = (double)line.x1, y1 = (double)line.y1,				x2 = (double)line.x2, y2 = (double)line.y2;		// theta = direction of line; perpendicular to line is theta-PI/2		double theta = Math.atan2(y2-y1, x2-x1);		// theta1 = direction of (x1, x2), e.g. (r1, theta1)		double theta1 = Math.atan2(y1, x1);		double[] v1 = {(double)x1, (double)y1, 0.0};		// length of perpendicular from origin to line		//   is ||(x1,y1)|| * cos(angle between (x1,y1) and (x2-x1,y2-y1))		double d = new Vector(v1).vectorLength() *						Math.cos(theta-Math.PI/2.0-theta1);		// perpendicular from line to origin		double[] offset = {-d * Math.cos(theta-Math.PI/2.0),						-d * Math.sin(theta-Math.PI/2.0),						0.0};		// move line perpendicularly to origin		Affine userInput1 = new Affine(offset);		// rotate to new orientation		Affine userInput2 = new Affine(hand.flip(viewMatrix, theta));		// add to orientation		ImageSet.addToOrientation(toView.inverse().transform(				userInput2.transform(userInput1.transform(toView))), true);		closeAllWindows();		setup();		return;	}	/* Finds LMS plane that fits picked points	 * Points xi, yi, zi, where i = 0, n-1	 * Centroid of points xc = sumi(xi)/n,  yc = sumi(yi)/n,	 *   zc = sumi(zi)/n	 * Plane: A*x+B*y+*Cz = D, where (A, B, C) is normal and D is distance	 *   from the origin along the normal.	 * The plane is defined by four parameters, A, B, C, and D.	 * Distance to plane = A*xi+B*yi+C*zi-D.	 * LMS distance = sumi{(A*xi+B*yi+C*zi-D)^2}	 * Partial differential wrt D -> 2*sumi(-1*(A*xi+B*yi+C*zi-D)) = 0	 *   => A*sumi(xi)+B*sumi(yi)+C*sumi(zi)-n*D = 0	 *   => the centroid (xc, yc, zc) is on the plane.	 * Partial differential wrt A, B, C using above for D:	 *  2*(xi-xc)*sumi(A*(xi-xc)+B*(yi-yc)+C*(zi-zc)) = 0	 *  2*(yi-yc)*sumi(A*(xi-xc)+B*(yi-yc)+C*(zi-zc)) = 0	 *  2*(zi-zc)*sumi(A*(xi-xc)+B*(yi-yc)+C*(zi-zc)) = 0	 *  => M*(A B C)T = 0, where	 *  m00 = sumi(xi-xc)^2, m11 = sumi(yi-yc)^2, m22 = sumi(zi-zc)^2	 *  m01 = m10 = sumi(xi-xc)*(yi-yc)	 *  m02 = m20 = sumi(xi-xc)*(zi-zc)	 *  m12 = m21 = sumi(yi-yc)*(zi-zc)	 * M*(A B C)T = 0 => (M+lambda*I)*(A B C)T = lambda*(A B C)T	 * Therefore this is an Eigenvector problem.  M and (M+lambda*I) have	 *   the same Eigenvectors, with Eigenvalues shifted by lambda.	 * Eigenvalue is the sum of squared distance to the plane; therefore,	 *   we want the smallest eigenvalue.	 */	void viewFromPicks() {		String[] viewNames = {"Axial", "Coronal", "Sagital"};		ResultsTable rt = ImageSet.getRt();		if(rt==null) {			IJ.error("First pick at least 3 points");			return;		}		int counter = rt.getCounter();		int n = counter;		if(n<3) {			IJ.error("At least 3 point are needed to define a plane.");			return;		}		GenericDialog gd = new GenericDialog("View from Picks");		gd.addMessage("Define new view from last points picked.");		gd.addNumericField("Number of points", (double)n, 0);		gd.addChoice("View", viewNames, viewNames[0]);		gd.showDialog();		if(gd.wasCanceled()) return;		n = (int) gd.getNextNumber();		if(n>counter) n = counter;		if(n<3) {			IJ.error("At least 3 point are needed to define a plane.");			return;		}		Vector newAxis = null;		switch (gd.getNextChoiceIndex()) {			case 0:				newAxis = new Vector(new double[] {0.0, 0.0, 1.0});				break;			case 1:				newAxis = new Vector(new double[] {0.0, 1.0, 0.0});				break;			case 2:				newAxis = new Vector(new double[] {1.0, 0.0, 0.0});				break;		}		float[][] picks = {rt.getColumn(ImageSet.X_COL),							rt.getColumn(ImageSet.Y_COL),							rt.getColumn(ImageSet.Z_COL)};		double[] center = {0.0, 0.0, 0.0};		for(int i=0; i<3; i++) {			for(int k=counter-n; k<counter; k++) {				center[i] += picks[i][k];			}			center[i] /= n;		}		double[][] m = new double[3][3];		for(int j=0; j<3; j++)			for(int i=0; i<3; i++)				for(int k=counter-n; k<counter; k++) {					m[j][i] += (picks[j][k]-center[j])*(picks[i][k]-center[i]);				}		Eigen e = new Eigen(m);		double[] eVal = e.getValues();		double[][] eVec = e.getVectors();		// normal to new plane is eigenvector with the smallest eigenvalue		int best;		if(eVal[0]<=eVal[1] && eVal[0]<= eVal[2]) best = 0;		else if(eVal[1]<=eVal[2]) best = 1;		else best = 2;		Vector norm = new Vector(eVec[best]);		double angle = newAxis.innerAngle(norm);		if(angle==Double.NaN) {			IJ.error("Angle is NaN");			return;		}		if(angle!=0.0) {			if(angle>Math.PI/2.0) angle = Math.PI-angle;			Vector axis = newAxis.cross(norm);			Quaternion q = new Quaternion(axis, angle);			ImageSet.setOrientation(new Affine(q.getMatrix()));		}		ImageSet.setIntersection(new Vector(center));		closeAllWindows();		setup();		return;	}	void rotateLine(String direction) {		Line line = getLine();	// sets is and view		if(line==null) return;		double x1 = (double)line.x1, y1 = (double)line.y1,				x2 = (double)line.x2, y2 = (double)line.y2;		// theta = direction of line; perpendicular to line is theta-PI/2		double theta = Math.atan2(y2-y1, x2-x1);		if(direction.equals("vertical"))			theta = -(Math.PI/2.0 - theta);		Affine userInput = null;		switch (ImageSet.getCurrentView()) {			case STACK:			case AXIAL:				userInput = new Affine(new RollMatrix(theta));				break;			case CORONAL:				userInput = new Affine(new YawMatrix(theta));				break;			case SAGITAL:				userInput = new Affine(new PitchMatrix(-theta));				break;			default:				IJ.error("resample: invalid view = "+									ImageSet.getCurrentView());				break;		}		ImageSet.addToOrientation(userInput, true);		closeAllWindows();		setup();		return;	}	// sets is and view	private Line getLine() {		int view = DoOption.AXIAL;		Roi roi = null;		ImagePlus imp = WindowManager.getCurrentImage();		for(int i=0; i<isv.size(); i++) {			is = (ImageSet) isv.elementAt(i);			view = is.inImageSet(imp);			if(view==NONE) continue;			roi = is.getImp(view).getRoi();			break;		}		if(roi==null || roi.getType()!=Roi.LINE)			outer: for(int i=0; i<isv.size(); i++) {				for(view=0; view<4; view++) {					is = (ImageSet) isv.elementAt(i);					roi = is.getImp(view).getRoi();					if(roi!=null && roi.getType()==Roi.LINE) break outer;				}			}		if(roi==null || roi.getType()!=Roi.LINE) {			IJ.error("Draw a line first.");			return null;		}		ImageSet.setCurrentView(view);		return (Line) roi;	}	private void incrementSlice(double inc) {		if(is==null) is = (ImageSet) isv.elementAt(0);		is.incrementSlice(inc);		return;	}	private void nextView() {		int view = ImageSet.getCurrentView();		view += 1;		if(view>DoOption.SAGITAL) view = DoOption.AXIAL;		ImageSet.setCurrentView(view);		return;	}	// save axial, coronal, or sagital slices	void output() {		if(isv.size()<=0) return;		// get user input		String[] stackName = new String[isv.size()];		String[] viewName = new String[3];		int stackChoice = 0, viewChoice = 0;		for(int i=0; i<3; i++)			viewName[i] = VIEW_NAME[i];		for(int i=0; i<isv.size(); i++)			stackName[i] = ((ImageSet) isv.elementAt(i)).							getImp(STACK).getTitle();		GenericDialog gd = new GenericDialog("Output");		gd.addChoice("Stack:", stackName, stackName[stackChoice]);		gd.addChoice("View:", viewName, viewName[viewChoice]);		gd.showDialog();		stackChoice = gd.getNextChoiceIndex();		viewChoice = gd.getNextChoiceIndex();		// set up for output		is = (ImageSet) isv.elementAt(stackChoice);		Handedness hand = is.getHand();		ImagePlusPlus impp = is.getImpp();		ImagePlus imp = is.getImp(STACK);		ImageProcessor ip = imp.getProcessor();		is.setView(viewChoice);		ImagePlusPlus imppOut = new ImagePlusPlus(imp);		imppOut.setReg(impp.getView().transform(impp.getReg()));		int[] outD = imppOut.getOutD(true);		ImageStack stack = new ImageStack(outD[0], outD[1],												ip.getColorModel());		double[] minD = imppOut.getMinD(false);		double dispMin = Double.MAX_VALUE, dispMax = 0.0;		// do output		for(int n=0; n<outD[2]; n++) {			IJ.showStatus(new Integer(n+1).toString()+"/"+						new Integer(outD[2]).toString());			IJ.showProgress((double)n / (double)outD[2]);			double[] offset = {-minD[0], -minD[1], -minD[2]-(double)n};			Affine sliceOffset = new Affine(offset);			imppOut.setView(sliceOffset);			ImageProcessor ipOut = imppOut.getSliceData(								ip.createProcessor(outD[0], outD[1]));			ipOut.resetMinAndMax();			dispMin = Math.min(dispMin,ipOut.getMin());			dispMax = Math.max(dispMax,ipOut.getMax());			stack.addSlice(null, ipOut);		}		IJ.showProgress(1.0);		ImagePlus impOut = new ImagePlus(viewName[viewChoice]+							"-"+stackName[stackChoice], stack);		impOut.setCalibration(imp.getCalibration().copy());		impOut.getProcessor().setMinAndMax(dispMin, dispMax);		FileSaver fs = new FileSaver(impOut);		fs.saveAsTiff();		return;	}	void picks(String arg) {		ResultsTable rt = ImageSet.getRt();		if(rt==null) return;		TextPanel tp = IJ.getTextPanel();		if(arg.equals("delete all")) {			rt.reset();			if(tp!=null) {				tp.selectAll();				tp.clearSelection();			}		} else if(arg.equals("delete last")) {			int n = rt.getCounter();			if(n<=0) return;			if(n==1) {				picks("delete all");				return;			}			float[][] rtTemp = new float[7][];			for(int i=0; i<7; i++)				rtTemp[i] = rt.getColumn(i);			picks("delete all");			for(int j=0; j<n-1; j++) {				rt.incrementCounter();				for(int i=0; i<7; i++)					rt.addValue(i, (double)rtTemp[i][j]);				if(j==0) ImageSet.rtHeadings();				IJ.write(rt.getRowAsString(j));			}		} else if(arg.equals("refresh")) {			int n = rt.getCounter();			if(n<=0) return;			if(tp!=null) {				tp.selectAll();				tp.clearSelection();			}			IJ.setColumnHeadings(rt.getColumnHeadings());   			for(int j=0; j<n; j++)				IJ.write(rt.getRowAsString(j));		}		return;	}} // end of Reorient