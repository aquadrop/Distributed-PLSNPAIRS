package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;/** * This class finds the eigenvectors and eigenvalues of a real symmetric * matrix. * See Press WH, Teukolsky SA, Vetterling WT, Flannery BP: Numverical * recipes in C++. Cambridge University Press, 2002, Chap. 11 * Instead of over writting input, intermediate values are retained. * * @param a input matrix * @param d diagonal elements of the tridiagonal matrix from householder * @param e off diagonal elements of the tridiagonal matrix from householder * @return Q orthogonal matrix from householder (intermediate result) * @return d diagonal elements of tridiagonal matrix (intermediate result) * @return e off diagonal elements of tridiagonal matrix (intermediate result) * @return values Eigenvalues * @return vectors Eigenvectors * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 17July2002 */public class Eigen {	private double[][] a = null, q = null, z = null;	private double[] d = null, e = null, v = null, w = null;	/** Usual constructor */	public Eigen(double[][] a)				throws IllegalArgumentException, ArithmeticException {		int len = a.length;		for(int j=0; j<len; j++)			if(a[j].length!=len)				throw new IllegalArgumentException(										"Input matrix is not square.");		this.a = a;		q = new double[len][];		for(int j=0; j<len; j++) {			q[j] = new double[len];			System.arraycopy(a, 0, q, 0, len);		}		d = new double[len];		e = new double[len];		householder();		v = new double[len];		System.arraycopy(d, 0, v, 0, len);		w = new double[len];		System.arraycopy(e, 0, w, 0, len);		z = new double[len][];		for(int j=0; j<len; j++) {			z[j] = new double[len];			System.arraycopy(q, 0, z, 0, len);		}		TridiagonalQL();		return;	}	/** Constructor given d, diagonal, and e, off diagonal elements of	 *  a real symmetric tridiagonal matrix. */	public Eigen(double[] d, double[] e, double[][] q) 					throws IllegalArgumentException, ArithmeticException {		int len = q.length;		for(int j=0; j<len; j++)			if(q[j].length!=len)				throw new IllegalArgumentException(										"Input matrix is not square.");		if(d.length!=len || e.length!= len)			throw new IllegalArgumentException("Incompatible dimensions.");		v = new double[len];		System.arraycopy(d, 0, v, 0, len);		w = new double[len];		System.arraycopy(e, 0, w, 0, len);		z = new double[len][];		for(int j=0; j<len; j++) {			z[j] = new double[len];			System.arraycopy(q, 0, z, 0, len);		}		TridiagonalQL();		return;	}	/** Orthogonal matrix Q */	public double[][] getQ() {return q;}	/** Diagonal elements of tridiagonal matrix */	public double[] getD() {return d;}	/** Off-daigonal elements of tridiagonal matrix, Q */	public double[] getE() {return e;}	/** Eigenvalues */	public double[] getValues() {return v;}	/** Eigenvectors, columns of z */	public double[][] getVectors() {		int len = z.length;		double[][] out = new double[len][len];		for(int j=0; j<len; j++)			for(int i=0; i<len; i++)				out[i][j] = z[j][i];		return out;	}	// see tred2 in Press	private void householder() {		double scale, hh, h, g, f;			int n = d.length;		for(int i=n-1; i>0; i--) {			int l = i-1;			h = scale = 0.0;			if (l>0) {				for(int k = 0; k<l+1; k++)					scale += Math.abs(q[i][k]);				if (scale==0.0)					e[i] = q[i][l];				else {					for(int k = 0; k<l+1; k++) {						q[i][k] /= scale;						h += q[i][k]*q[i][k];					}					f = q[i][l];					g = (f>=0.0 ? -Math.sqrt(h) : Math.sqrt(h));					e[i] = scale*g;					h -= f*g;					q[i][l] = f-g;					f = 0.0;					for(int j = 0; j<l+1; j++) {					// Next statement can be omitted if eigenvectors not wanted						q[j][i] = q[i][j]/h;						g = 0.0;						for(int k = 0; k<j+1; k++)							g += q[j][k]*q[i][k];						for(int k = j+1; k<l+1; k++)							g += q[k][j]*q[i][k];						e[j] = g/h;						f += e[j]*q[i][j];					}					hh = f/(h+h);					for(int j = 0; j<l+1; j++) {						f = q[i][j];						e[j] = g = e[j]-hh*f;						for(int k = 0; k<j+1; k++)							q[j][k] -= (f*e[k]+g*q[i][k]);					}				}			} else				e[i] = q[i][l];			d[i] = h;		}		// Next statement can be omitted if eigenvectors not wanted		d[0] = 0.0;		e[0] = 0.0;		// Contents of this loop can be omitted if eigenvectors not		//	wanted except for statement d[i] = q[i][i];		for(int i = 0; i<n; i++) {			int l = i;			if (d[i]!=0.0) {				for(int j = 0; j<l; j++) {					g = 0.0;					for(int k = 0; k<l; k++)						g +=  q[i][k]*q[k][j];					for(int k = 0; k<l; k++)						q[k][j] -= g*q[k][i];				}			}			d[i] = q[i][i];			q[i][i] = 1.0;			for(int j = 0; j<l; j++) q[j][i] = q[i][j] = 0.0;		}		return;	}	// see tqli in Press	private void TridiagonalQL() throws ArithmeticException {		double s,r,p,g,f,dd,c,b;			int n = v.length;		for(int i=1; i<n; i++) w[i-1] = w[i];		w[n-1] = 0.0;		for(int l=0; l<n; l++) {			int i, m, iter = 0;			do {				for(m=l; m<n-1; m++) {					dd = Math.abs(v[m])+Math.abs(v[m+1]);					if (Math.abs(w[m])+dd==dd) break;				}				if (m!=l) {					if (iter++ == 30)						throw new ArithmeticException(								"Too many iterations in TridiagonalQL");					g = (v[l+1]-v[l])/(2.0*w[l]);					r = pythag(g, 1.0);					g = v[m]-v[l]+w[l]/(g+sign(r, g));					s = c = 1.0;					p = 0.0;					for(i=m-1; i>=l; i--) {						f = s*w[i];						b = c*w[i];						w[i+1] = (r = pythag(f, g));						if (r==0.0) {							v[i+1] -= p;							w[m] = 0.0;							break;						}						s = f/r;						c = g/r;						g = v[i+1]-p;						r = (v[i]-g)*s+2.0*c*b;						v[i+1] = g+(p = s*r);						g = c*r-b;						// Next loop can be omitted if eigenvectors not wanted						for(int k=0; k<n; k++) {							f = z[k][i+1];							z[k][i+1] = s*z[k][i]+c*f;							z[k][i] = c*z[k][i]-s*f;						}					}					if (r==0.0 && i>=l) continue;					v[l] -= p;					w[l] = g;					w[m] = 0.0;				}			} while (m!=l);		}		return;	}	private double sign(double a, double b) {		return b>=0.0 ? Math.abs(a) : -Math.abs(a);	}	private double pythag(double a, double b) {		double absa,absb;			absa=Math.abs(a);		absb=Math.abs(b);		if (absa>absb) return absa*Math.sqrt(1.0+(absb/absa)*(absb/absa));		else return (absb==0.0 ? 0.0 :							absb*Math.sqrt(1.0+(absa/absb)*(absa/absb)));	}} // end of EigenVectors