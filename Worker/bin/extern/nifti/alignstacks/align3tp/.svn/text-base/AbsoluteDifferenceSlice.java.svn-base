package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the sum of the absolute difference for slices from * two ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional ROI. * It works on a 2D slices using the roi from an ImageJ ImageProcessor. * The slices are made zero mean prior to calculating the sum of the * absolute differences in order that there will be roughly equal positive * and negative values. * AD = 1 - sum(|(f-fm)-(g-gm)|)/sum(|f-fm|+|g-gm|) *   where fm and gm are the respective means.  Range [0,1]. * The absolute difference is multiplied by the change penalty calculated * in SliceFunction.  When the overlap is less than minOverlap, then * -distanceSq/halfPenaltySq is returned [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param roi calculation is limited to the region in roi * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class AbsoluteDifferenceSlice extends SliceFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip = new ImageProcessor[2];	private int[] npix = {0, 0};	/** Constructor for AbsoluteDifference on two slices without an ROI using	 * default transformation. */	public AbsoluteDifferenceSlice(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for AbsoluteDifference on two slices without an ROI. */	public AbsoluteDifferenceSlice(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for AbsoluteDifference on two slices with an ROI. */	public AbsoluteDifferenceSlice(ImagePlusPlus[] imppIn, int transform,			Roi roi) throws IllegalArgumentException, ArithmeticException {		super(imppIn, transform, roi);		ip[0] = imppIn[0].getSlice(roiBoundry);		npix[0] = imppIn[0].getNpixSlice();		if(npix[0]==0) throw new ArithmeticException("Zero pixels in ROI");		return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		ip[1] = imppIn[1].getSlice(roiBoundry);		if(ip[0]==null || ip[1]==null)			throw new ArithmeticException("ImageProcessor is null.");		npix[1] = imppIn[1].getNpixSlice();		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		int h = Math.min(ip[0].getHeight(), ip[1].getHeight());		int w = Math.min(ip[0].getWidth(),ip[1].getWidth());		int[][] row = new int[2][w];		int npixRoi = 0;		double[] mean = {0.0, 0.0}, nMean = {0.0, 0.0};		boolean[] fp = {ip[0] instanceof FloatProcessor,	// hoist						ip[1] instanceof FloatProcessor};		for(int j=0; j<h; j++) {			for(int k=0; k<2; k++) ip[k].getRow(0, j, row[k], w);			for(int i=0; i<w; i++) {				// docs stay Black is in, but code says back is out				if(maskArray!=null &&							maskArray[j*w+i]==(byte)ImageProcessor.BLACK)					continue;				npixRoi++;				for(int k=0; k<2; k++) {					if(fp[k])						nMean[k] = Float.intBitsToFloat(row[k][i]);					else						nMean[k] = (float)row[k][i];				}			}		}		if(npixRoi==0) throw new ArithmeticException("Zero pixels in ROI");		for(int k=0; k<2; k++) mean[k] = nMean[k]/npixRoi;		double nAbs = 0.0, nAbsDiff =0.0;		for(int j=0; j<h; j++) {			double[] temp = {0.0, 0.0};			for(int k=0; k<2; k++) ip[k].getRow(0, j, row[k], w);			for(int i=0; i<w; i++) {				// docs stay Black is in, but code says back is out				if(maskArray!=null &&							maskArray[j*w+i]==(byte)ImageProcessor.BLACK)					continue;				for(int k=0; k<2; k++) {					if(fp[k])						temp[k] = Float.intBitsToFloat(row[k][i]);					else						temp[k] = (float)row[k][i];					temp[k] -= mean[k];				}				nAbs += Math.abs(temp[0])+Math.abs(temp[1]);				nAbsDiff += Math.abs(temp[0]-temp[1]);			}		}		return changePenalty*(1.0-nAbsDiff/nAbs);	}}	// end of AbsoluteDifferenceSlice