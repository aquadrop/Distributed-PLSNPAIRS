package extern.nifti.alignstacks.align3tp;import ij.plugin.frame.*;import ij.*;import ij.gui.*;import ij.process.*;import extern.nifti.alignstacks.align3tp.Handedness;	// force compileimport extern.nifti.alignstacks.align3tp.ImageSet;	// force compileimport extern.nifti.alignstacks.align3tp.Matrix.*;	// imported nested top-level classes/** * This class is an abstract parent for Display and Reorient classes. * It is needed for ImageSet to access the class variables and the *   updateWindows() method in both classes.  Also holds common code. * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 22April2002 * * @see extern.nifti.alignstacks.align3tp.Display * @see extern.nifti.alignstacks.align3tp.Reorient */public abstract class DoOption {	// 0-2 guaranteed to be axial, coronal, and sagital	// 3 guaranteed to be stack	final static int AXIAL = 0, CORONAL = 1, SAGITAL = 2,					STACK = 3, ALL_VIEWS = 4, NONE = 5;	final static String[] VIEW_NAME = {"Axial", "Coronal", "Sagital",					"Axial stack", "All views", "None"};	// one or more ImageSet objects are stored in this vector	protected java.util.Vector isv = new java.util.Vector();	protected boolean rightHanded;	protected PlugInFrame myPlugInFrame;	abstract public void showAbout();	abstract public boolean setup();	abstract public void doCommand(int index) throws InterruptedException;	public boolean lock() {		for(int i=0; i<isv.size(); i++)			if(!((ImageSet) isv.elementAt(i)).lock()) {				 for(int j=0; j<i; j++)				 	((ImageSet) isv.elementAt(j)).unlock();				 return false;			}		return true;	}	public void unlock() {		for(int i=0; i<isv.size(); i++)			((ImageSet) isv.elementAt(i)).unlock();		return;	}	public void closeAllWindows() {		closeWindows(ALL_VIEWS);		return;	}		void closeWindows(int view) {		for(int i=0; i<isv.size(); i++)			((ImageSet) isv.elementAt(i)).closeWindow(view);		return;	}		void updateWindows(int view) {		for(int i=0; i<isv.size(); i++)			((ImageSet) isv.elementAt(i)).updateWindow(view);		return;	}	void startOver() {		closeAllWindows();		isv.removeAllElements();		ImageSet.startOver();		setup();		return;	}	// open another stack	void additionalStack() {		ImagePlus imp = WindowManager.getCurrentImage();		for(int i=0; i<isv.size(); i++)			if(((ImageSet) isv.elementAt(i)).inImageSet(imp) != NONE) {				IJ.error("First, select a new stack by clicking on it.\n"+					"File/Open... or File/Import if necessary.");				return;			}		isv.addElement((Object) new ImageSet(rightHanded, this, true));		setup();		return;	}	// increase number of slices by increasing the z scale factor in reg	void scaleStacks() {		double[] scale = {1.0, 1.0, 2.0};		GenericDialog gd = new GenericDialog("Interpolate Stack");		gd.addMessage("Scale factor in slice direction.\n"+					"Facilitates visualization when the slice-to-slice\n"+					"resolution is less than the in-plane resolution");		gd.addNumericField("Stack scale factor:", scale[2], 1);		gd.showDialog();		if(gd.wasCanceled()) return;		scale[2] = gd.getNextNumber();		if(scale[2]==1.0) return;		Affine userInput = new Affine(new ScaleMatrix(scale));		ImageSet.addToOrientation(userInput, false);		for(int i=0; i<isv.size(); i++)			((ImageSet) isv.elementAt(i)).closeScaledWindows();		setup();		return;	}	void rotate(String view) {		double angle = 90.0;		GenericDialog gd = new GenericDialog("Rotate");		gd.addNumericField("Angle:", angle, 0);		gd.addCheckbox("Interpolate", ImageSet.getInterpolate());		gd.showDialog();		if(gd.wasCanceled()) return;		angle = gd.getNextNumber();		ImageSet.setInterpolate(gd.getNextBoolean());		if(angle==0.0) return;		Affine userInput = null;		if(view=="axial")			userInput = new Affine(new RollMatrix(angle*Math.PI/180.0));		else if(view=="coronal")			userInput = new Affine(new YawMatrix(angle*Math.PI/180.0));		else if(view=="sagital")			userInput = new Affine(new PitchMatrix(-angle*Math.PI/180.0));		ImageSet.addToOrientation(userInput, true);		closeAllWindows();		setup();		return;	}	void mirror(String axis) {		ImageSet.mirror(axis);		if(axis=="x") {			updateWindows(AXIAL);			updateWindows(CORONAL);		}else if(axis=="y") {			updateWindows(AXIAL);			updateWindows(SAGITAL);		} else {			updateWindows(CORONAL);			updateWindows(SAGITAL);		}		return;	}	void printViewReg() {		for(int i=0; i<isv.size(); i++) {			ImagePlusPlus impp = ((ImageSet) isv.elementAt(i)).getImpp();			String s = ((ImageSet) isv.elementAt(i)).getImp(STACK).										getTitle();			IJ.write(s+": View\n"+impp.getView().toString()+					s+": Reg\n"+impp.getReg().toString()+					"\n");		}		IJ.showStatus("");		return;	}	void greetings() {		IJ.showMessage("Greetings from "+this.getClass().getName());		return;	}}