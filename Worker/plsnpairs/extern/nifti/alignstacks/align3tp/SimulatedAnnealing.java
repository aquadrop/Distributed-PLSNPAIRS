package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import java.util.Random;import ij.IJ;	// for debugging with IJ.write()/** * This class implements simulated annealing. * See Press WH, Teukolsky SA, Vetterling WT, Flannery BP: Numverical * recipes in C++. Cambridge University Press, 2002, Chap. 10 * This algorithm uses a downhill Simplex method with the addition of * simulated annealing so that the algorithm will go uphill with a * probability of exp(-(E2-E1)/T), where E is the output of a function, * funk, and T is a "temperature", which is an input. * A simplex is ndim+1 vertices, the lines connecting them, and the surfaces. * The simplex, p, is defined by ndim+1 points in ndim, e.g. the origin * and then a vertex along each dimension. * After instantiating this class, amebsa() is called to do iter * iterations at a single tempurature, temptr. * The calling program can provide algorithm for iterating the temperature * or rule*(), below, can be used. * pb and yb from amebsa() will be the best vertex every evaluated; * however rule*() resets yb, so pb and yb are the best vertex on the * current call.  For rule*(), bestPb and bestYb store the best vertex * ever.  bestPb and bestYb are not used if amebsa() is called directly. * * @param funk a function of x = double[ndim] * @param p a simplex of mpts (= ndim+1) points in ndim dimensions, or null * @param ftol tolerance > machine precision (sp>3e-8, dp>e-15), or 0.0 * @return yb the best functional value ever found by amebsa() * @return pb the vertex for at which yb occurs * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 7September2004 */public class SimulatedAnnealing {	private static int ITER_MAX = 10, RULE_REPEATS = 1;	private Function funk;	private double[][] p;	private double ftol, stopRule = 0.1;	// y is a vertex	private double[] y, pb, bestPb = null;	private double yb = Double.MAX_VALUE, bestYb = Double.MAX_VALUE;	private int iter;	// common block for instantiation, amebsa, and amotsa	private int mpts, ndim;	private double[] psum;	private double yhi, tt;	private Random rand;	/** Constructor.  p==null -> center and points at the ends of unit	 * vectors.  ftol==0.0 -> 3.0e-14. */	public SimulatedAnnealing(Function funk, double[][] p, double ftol)				throws IllegalArgumentException, ArithmeticException {		this.funk = funk;		ndim = funk.length();		if(ndim<=1)			throw new IllegalArgumentException("This simulated annealing "+					"alorgithm requires at least 2 dimensions.");		if(p!=null)			this.p = p;		else			this.p = makeP(ndim+1, ndim, 1.0);		mpts = this.p.length;		if(mpts<=ndim)			throw new IllegalArgumentException("Too few vertices");		for(int i=0; i<mpts; i++)			if(this.p[i].length<ndim)				throw new IllegalArgumentException("Incompatible dimensions");		this.ftol = ftol==0.0 ? 3.0e-14 : ftol;		y = new double[mpts];		for(int i=0; i<mpts; i++)			y[i] = funk.value(new Vector(this.p[i]));		pb = new double[ndim];		psum = new double[ndim];		rand = new Random();		return;	}	/** Simplex. */	public double[][] getP() {return p;}	/** Best vertex from amebsa(). */	public double[] getPb() {return pb;}	/** Value at best vertex from amebsa(). */	public double getYb() {return yb;}	/** Best vertx from rule*(). */	public double[] getBestPb() {return bestPb;}	/** Value at best vertex from rule*() */	public double getBestYb() {return bestYb;}	/** Number or iterations. */	public int getIter() {return iter;}	/** Stopping criteria for rule*() in distance between best vertices. */	public void setStopRule(double stop) {stopRule = stop; return;}	/** Fractional decrease in temperature (1-e)*T after moves moves.	 * This is the first sugested annealing schedule in Press.  I	 * have added a counter, iter, which stops the process after ITER_MAX	 * temperature changes.  In addition to ITER_MAX, other parameters	 * which can be set include: 1. moves, the number of downhill simplex	 * moves for each temperature. 2. e, the fractional decrease in	 * temperature, T[i+1] = (1-e)+T[i], on each iteration.  3. temptr,	 * the starting temperature.  Temptr should be on the order of,	 * maybe larger than, the change in funk on one move.  4. stopRule,	 * the distance changed in one move.  Since stop rule is based on the	 * distance in simplex space, the metric in each dimension should be	 * comprable.  5. RULE_REPEATS, number of times in a row that stopRule	 * must be satisfied.	 *	 * @param t initial temperature about funk(y[i+1])-funk(y[i])	 * @param e fractional decrease (1-e)	 * @param moves number of iterations at each temperature	 * @return bestPb the best vertex	 * @return bestYb the value at bestPb	 */	public double[] rule1(double temptr, double e, int moves)			throws IllegalArgumentException {		int movesLeft = 0;	// # of iterations left to do by amebsa		int nStop = 0;	// number of times stopRule has been satisfied		Vector currentPb, lastPb = new Vector(pb);		if(1.0<=e || e<=0.0)			throw new IllegalArgumentException("e must be in (0,1)");		// movesLeft>0 -> hit ftol criteria in amebsa (unlikely)		// iter>ITER_MAX -> failure (consider increasing ITER_MAX)		// break from stopping rule (below) normal termination		for (iter=1; movesLeft<=0&&iter<=ITER_MAX; iter++) {			yb = Double.MAX_VALUE;	// reset yb			movesLeft = amebsa(moves, temptr);			currentPb = new Vector(pb);			if(yb<bestYb) {				bestYb = yb;				bestPb = pb;			}			// best vertex moves distance less than stopRule in one loop			// likely stopping rule			if(currentPb.sub(lastPb).vectorLength() < stopRule) {				nStop++;				// No movement over last 1 move, can be changed to 2 or				// more to make sure we are at a minimum.				if(nStop>=RULE_REPEATS)					break;			} else				nStop = 0;			lastPb = currentPb;			temptr = temptr*(1.0-e);		}		return bestPb;	}	/** Makes vertices at scale on each axis and at center point. */	public static double[][] makeP(int m, int n, double scale) {		double[][] myP = new double[m][n];		for(int i=0; i<n; i++) myP[0][i] = 0.0;	//center point		for(int j=1; j<m; j++)			for(int i=0; i<n; i++)				myP[j][i] = j-1==i ? scale : 0.0;		return myP;	}	/** Does iter iterations at a temparature of temptr.	 * return with a positive value means early convergence 	 *	 * @param iter number of iterations	 * @param temptr temperature, T	 * @return iter number of iterations remaining	 */	public int amebsa(int iter, double temptr) {		int ihi, ilo ;		double rtol, ylo, ynhi, ysave, yt, ytry;			tt = -temptr;		get_psum(p);		do {			// Determine the highest (worst) point, the next highest, and			// the lowest (best)			ilo = 0; ihi = 1;			// Vertices get a random thermal fluctuation.			ynhi = ylo = y[0]+tt*Math.log(ran1());			yhi = y[1]+tt*Math.log(ran1());			if (ylo > yhi) {				ihi = 0; ilo = 1; ynhi = yhi; yhi = ylo; ylo = ynhi;			}			// Loop over points in simplex (must be >=3 points)			for (int i=3; i<=mpts; i++) {				yt = y[i-1]+tt*Math.log(ran1());				if (yt <= ylo) {					ilo = i-1; ylo = yt;				}				if (yt > yhi) {					ynhi = yhi; ihi = i-1; yhi = yt;				} else if (yt > ynhi) {					ynhi = yt;				}			}			rtol = 2.0*Math.abs(yhi-ylo)/(Math.abs(yhi)+Math.abs(ylo));			// Compute the fractonal range from highest to lowest and			// return if satisfactory			if (rtol<ftol || iter<0) {				double temp;				temp = y[0]; y[0] = y[ilo]; y[ilo] = temp;				for (int n=0; n<ndim; n++) {					temp = p[0][n]; p[0][n] = p[ilo][n]; p[ilo][n] = temp;				}				break;			}			iter -= 2;			// Begin a new iteration.  First extrapolate by a factor -1			// through the face of the simplex across from the highest			// point, i.e. reflect the simplex from the high point.			ytry = amotsa(ihi, -1.0);			if (ytry <= ylo) {				ytry = amotsa(ihi, 2.0);			} else if (ytry >= ynhi) {				ysave = yhi;				ytry = amotsa(ihi, 0.5);				// The reflected point is worse than the second-highest, so				// look for an intermediate lower point, i.e. do a				// one-dimensional contraction.				if (ytry>=ysave) {					for (int i=0; i<mpts; i++) {						if (i!=ilo) {							for (int j=0; j<ndim; j++) {								psum[j] = 0.5*(p[i][j]+p[ilo][j]);								p[i][j] = psum[j];							}							y[i] = funk.value(new Vector(psum));//IJ.write("y[i] = "+y[i]);						}					}					iter -= ndim;					get_psum(p);				}			} else ++iter;		} while(true);		return iter;	}	private void get_psum(double[][] p) {		for (int n=0; n<ndim; n++) {			double sum = 0.0;			for (int m=0; m<mpts; m++) sum += p[m][n];			psum[n]=sum;		}		return;	}	private double amotsa(int ihi, double fac) {		double fac1, fac2, yflu, ytry;			double[] ptry = new double[ndim];		fac1 = (1.0-fac)/ndim;		fac2 = fac1-fac;		for (int j=0; j<ndim; j++)			ptry[j] = psum[j]*fac1-p[ihi][j]*fac2;		ytry = funk.value(new Vector(ptry));//IJ.write("ytry = "+ytry);		if (ytry<=yb) {			for (int j=0; j<ndim; j++) pb[j] = ptry[j];			yb = ytry;		}		yflu = ytry-tt*Math.log(ran1());		if (yflu < yhi) {			y[ihi] = ytry;			yhi = yflu;			for (int j=0; j<ndim; j++) {				psum[j] += ptry[j]-p[ihi][j];				p[ihi][j] = ptry[j];			}		}		return yflu;	}		// Compiler should inline	private double ran1() {		double r;		do{r = rand.nextDouble();} while(r==0.0);		return r;	}}	// end of SimulatedAnnealing