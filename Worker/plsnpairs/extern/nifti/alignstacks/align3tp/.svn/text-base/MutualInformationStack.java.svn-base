package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;import java.lang.ArithmeticException;import java.awt.Rectangle;import ij.process.ImageProcessor;import ij.process.FloatProcessor;import ij.gui.Roi;import ij.IJ;/** * This class calculates the normalized mutual information for stacks from * two ImagePlusPlus objects using the reg Affine transform from the second * ImagePlusPlus and an optional boundry. * It works on a 3D stacks using the 3D region defined in alignment. * Normalized mutual information = I(A,B)/H(A,B), where I(A,B) is the * mutual information and H(A,B) is the mutual entropy.  Normalization * ameliorates the problem of the overlap of slices.  Entropy, * H(A,B) = sum(pdf(a,b)*log(1/pdf(a,b))).  The pair, (a,b), represtents * the values in the two slices at the same point A(x,y)=a and B(x,y)=b. * The probability density function pdf(a,b) is the number of corresponding * pixels in each image with values, (a,b), divided by the number of * overlapping pixels. * Mutual information = I(A,B) = sum(pdf(a,b)*log(pdf(a,b)/(pdf(a)*pdf(b)))) * For implementation, the pixel values need to be divided in discrete * values.  The number of values is given by bins  The pdf is a two * dimensional histogram, bins by bins in size.  Pixel values are mapped * to bins by slope*(value-min).  Values less than 0 are mapped to 0. * Values more than bins-1 are mapped to bins-1. * Range for normalized mutual information is 0 to 1 if the overlap is * adequate. * The normalized mutual information is multiplied by the change penalty * [0,1] calculated in StackFunction.  If the overlap is less than * minOverlap, then -distanceSq/halfPenaltySq is returned, [-inf,0]. * * @param imppIn input ImagePlusPluses * @param tranform type of registration transform * @param roi calculation is limited to the region in roi * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 28November2004 * * @see	extern.nifti.alignstacks.align3tp.ImagePlusPlus */public class MutualInformationStack extends StackFunction {	private final static int DEFAULT_TRANSFORM = 0;	private ImageProcessor[] ip0;	private ImageProcessor ip1;	private int bins = 256, binsSq = bins*bins;	private float[] min = {Float.MAX_VALUE, Float.MAX_VALUE},					max = {Float.MIN_VALUE, Float.MIN_VALUE};	private int[] npix = {0, 0};	private int nSlices;	/** Constructor for MutualInformation on two slices without a boundry using	 * default transformation. */	public MutualInformationStack(ImagePlusPlus[] imppIn)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, DEFAULT_TRANSFORM, null);		return;	}	/** Constructor for MutualInformation on two slices without a boundry. */	public MutualInformationStack(ImagePlusPlus[] imppIn, int transform)					throws IllegalArgumentException, ArithmeticException {		this(imppIn, transform, null);		return;	}	/** Constructor for MutualInformation on two slices with a boundry and	  * the transform specified.  roiBoundry from StackFunction */	public MutualInformationStack(ImagePlusPlus[] imppIn, int transform,				int[][] boundryIn) throws IllegalArgumentException,				ArithmeticException, UserEscapeException {		super(imppIn, transform, boundryIn);		nSlices = boundry[1][2]-boundry[0][2]+1;		ip0 = new ImageProcessor[nSlices];		Affine oldView, view = new Affine();		oldView = imppIn[0].getView();		imppIn[0].setView(view);		// get ip[0], max[0], min[0], and npix[0]		npix[0] = 0;		for(int slice=0; slice<nSlices; slice++) {			if(win!=null && !win.running)				throw new UserEscapeException("User halt");			imppIn[0].setViewOffset(-(slice+boundry[0][2]));			ip0[slice] = imppIn[0].getSlice(roiBoundry);			// ip0 should not be null, programming check			if(ip0[slice]==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 1 is null.");			ip0[slice].resetMinAndMax();			min[0] = Math.min(min[0], (float)ip0[slice].getMin());			max[0] = Math.max(max[0], (float)ip0[slice].getMax());			npix[0] += imppIn[0].getNpixSlice();		}		imppIn[0].setView(oldView);		if(npix[0]==0) throw new ArithmeticException("Zero pixels in ROI");		oldView = imppIn[1].getView();		imppIn[1].setView(view);		// get max[1], min[1], and npix[1]		npix[1] = 0;		for(int slice=0; slice<nSlices; slice++) {			if(win!=null && !win.running)				throw new UserEscapeException("User halt");			imppIn[1].setViewOffset(imppIn[1].validViewOffset(												-(slice+boundry[0][2])));			ip1 = imppIn[1].getSlice(roiBoundry);			ip1.resetMinAndMax();			min[1] = Math.min(min[1], (float)ip1.getMin());			max[1] = Math.max(max[1], (float)ip1.getMax());			npix[1] += imppIn[1].getNpixSlice();		}		imppIn[1].setView(oldView);		if(npix[1]==0) throw new ArithmeticException("Zero pixels in ROI");		return;	}	/** @param bins number of bins for quantization of pixel values */	public void setBins(int bins) {		this.bins = bins;		binsSq = bins*bins;		return;	}	/** @param min pixel value for bin value zero */	public void setMin(double[] min) {		for(int k=0; k<2; k++)			this.min[k] = (float)min[k];			return;	}	/** @param max pixel value for bin value bins-1 */	public void setMax(double[] max) {		for(int k=0; k<2; k++)			this.max[k] = (float)max[k];			return;	}	/** Value of the correlation coefficient of two images. */	protected double eval() throws ArithmeticException, UserEscapeException {		if(win!=null && !win.running)			throw new UserEscapeException("User halt");		long[][] pdf1DL = new long[2][bins];		long[] pdf2DL = new long[binsSq];		int npixRoi = 0;		Affine oldView, view = new Affine();		oldView = imppIn[1].getView();		imppIn[1].setView(view);		float[] slope = new float[2];	// hoist		for(int k=0; k<2; k++)			slope[k] = (float)(bins-1)/(max[k]-min[k]);		for(int slice=0; slice<nSlices; slice++) {			if(win!=null && !win.running) {				imppIn[1].setView(oldView);				throw new UserEscapeException("User halt");			}			imppIn[1].setViewOffset(imppIn[1].validViewOffset(												-(slice+boundry[0][2])));			ip1 = imppIn[1].getSlice(roiBoundry);			// ip1 should not be null, programming check			if(ip1==null) throw new ArithmeticException(						"ImageProcessor "+slice+"from stack 2 is null.");			int h = Math.min(ip0[slice].getHeight(), ip1.getHeight());			int w = Math.min(ip0[slice].getWidth(), ip1.getWidth());			npixRoi += h*w;			int[][] row = new int[2][w];			boolean[] fp = new boolean[2];	// hoist			fp[0] = ip0[slice] instanceof FloatProcessor;			fp[1] = ip1 instanceof FloatProcessor;			// make pdfs			for(int j=0; j<h; j++) {				int[] temp = {0, 0};				ip0[slice].getRow(0, j, row[0], w);				ip1.getRow(0, j, row[1], w);				for(int i=0; i<w; i++) {					for(int k=0; k<2; k++) {						float f;						if(fp[k])							f = Float.intBitsToFloat(row[k][i]);						else							f = (float)row[k][i];						temp[k] = (int) (slope[k]*(f-min[k]));						temp[k] = Math.min(bins-1, Math.max(0, temp[k]));						pdf1DL[k][temp[k]]++;					}					pdf2DL[temp[1]*bins+temp[0]]++;				}			}		}		imppIn[1].setView(oldView);		if((double)npix[1]/(double)npix[0] < minOverlap)			return -distanceSq/halfPenaltySq;		float inverseNpixRoi = 1.0F/(float)npixRoi;		float[][] pdf1DF = new float[2][bins];		float[] pdf2DF = new float[binsSq];		for(int i=0; i<bins; i++)			for(int k=0; k<2; k++)				pdf1DF[k][i] = inverseNpixRoi*(float)pdf1DL[k][i];		for(int i=0; i<binsSq; i++)			pdf2DF[i] = inverseNpixRoi*(float)pdf2DL[i];		float mutual = 0F, jentropy = 0F;		for(int j=0; j<bins; j++)			for(int i=0; i<bins; i++) {				float prod01 = pdf1DF[1][j]*pdf1DF[0][i];				if(prod01==0F) continue;				int n = j*bins+i;				if(pdf2DF[n]==0) continue;				mutual += pdf2DF[n]*(float)Math.log(pdf2DF[n]/prod01);				jentropy -= pdf2DF[n]*(float)Math.log(pdf2DF[n]);		}		double r = (double)mutual/(double)jentropy;		return changePenalty*r;	}}	// end of MutualInformationStack