package extern.nifti.alignstacks.align3tp;import java.awt.*;import java.awt.event.*;import java.awt.image.ColorModel;import java.io.*;import ij.plugin.frame.*;import ij.*;import ij.gui.*;import ij.process.*;import ij.measure.Calibration;/** * Affine transformation * x' = xform*x + offset * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 3November2004 * * @see Align3_TP */public class Affine implements java.io.Serializable {	private Matrix xform = new Matrix(3,3);	// linear transform	private double[] offset = {0.0, 0.0, 0.0};	Affine() {		return;	}	Affine(double[] offset) {		setOffset(offset);		return;	}	Affine(Matrix xform) {		setMatrix(xform);		return;	}	Affine(Matrix xform, double[] offset) {		setMatrix(xform);		setOffset(offset);		return;	}	Affine(Affine in) {		setMatrix(new Matrix(in.getMatrix()));		double[] inOff = in.getOffset();		for(int i=0; i<3; i++)			offset[i] = inOff[i];		return;	}	boolean isIdentity() {		if(xform.isIdentity()					&& offset[0]==0.0 && offset[1]==0.0 && offset[2]==0.0)			return true;		else			return false;	}	void setMatrix(Matrix xform) {		for(int i=0; i<Math.min(3, xform.r); i++)			for(int j=0; j<Math.min(3, xform.c); j++)				this.xform.m[i][j] = xform.m[i][j];		return;	}	void setOffset(double[] offset) {		for(int i=0; i<Math.min(3, offset.length); i++)			this.offset[i] = offset[i];		return;	}	void setSlice(double offset2) {		this.offset[2] = offset2;		return;	}	Matrix getMatrix() {		return xform;	}	double[] getOffset() {		return offset;	}	// x' = xform*x + offset	Vector transform(Vector in) {		return xform.multiply(in).add(new Vector(offset));	}	// x = xform.inverse()*(x'-offset)	Vector inverse(Vector in) {		Matrix xformInverse = xform.inverse();		if(xformInverse==null) return null;		return xformInverse.multiply(in.sub(new Vector(offset)));	}	// x' = this.transform(in).transform(x)	//   e.g. transform of "in" applied to x gives x'	// defined as: x' = this{in{x}}	//   e.g. => in transforms x which is then transformed by this	// x' = this.transform(in.transform(x)	// x' = this.xform*(in.xform*x + in.offset) + this.offset	// x' = this.xform*in.xform*x + (this.xform*in.offset + this.offset)	Affine transform(Affine in) {		Matrix xformOut = xform.multiply(in.getMatrix());		Vector offOut = xform.multiply(new Vector(in.getOffset())).											add(new Vector(offset));		return new Affine(xformOut, offOut.value());	}	// x' = xform*x + offset	// x = xform.inverse() * (x'-offset)	// x = xform.inverse()*x' - xform.inverse()*offset	Affine inverse() {		Matrix xformOut = xform.inverse();		if(xformOut==null) return null;		Vector offOut = xformOut.multiply(new Vector(offset)).minus();		return new Affine(xformOut, offOut.value());	}	public String toString(int digits) {	// debugging		return "Transform\n"+xform.toString(digits)+"Offset\n"+				new Vector(offset).toString(digits);	}	public String toString() {	// debugging		return "Transform\n"+xform.toString()+"Offset\n"+				new Vector(offset).toString();	}}	// end of Affine