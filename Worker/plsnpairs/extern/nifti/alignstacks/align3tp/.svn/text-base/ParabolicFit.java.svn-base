package extern.nifti.alignstacks.align3tp;import java.lang.IllegalArgumentException;//import java.lang.ArithmeticException;import java.util.Random;import ij.IJ;//import ij.gui.PlotWindow;/** * This class implements a parbolic fit in order to find the subpixel * location of the maximum.  The idea is to avoid local maximum due to * interpolation effects when the transformed locations do not match the * locations of the pixel data.  It uses singular value decomposition to * do the fitting (perhaps a bit of over kill).  Note SVD finds maximum * whereas other Press algorithms do minimization; therefore, this routine * does -func.value() * * Could consider abstract fit class for Powell, simulated annealing, * and Parabolic Fit. * * @param func function to be minimized (-func maximized) * @param p starting point * @param xi set of vector (columns) directions to fit * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 3August2004 */public class ParabolicFit {	private static int ndata = 20;	// number of data points	private static double range = 10.0;	// (-range/2, range/2)	private Vector p;	private double[][] xi;	private Function func;	private double fret;	private int n;	/** This constructor starts with unit vectors, xi. */	public ParabolicFit(Function func, double[] p)				throws IllegalArgumentException {		this.p = new Vector(p);		n = p.length;		if(n!=func.length())			throw new IllegalArgumentException("Incompatible dimensions");		xi = new double[n][n];		for(int j=0; j<n; j++)			for(int i=0; i<n; i++)				xi[j][i] = i==j ? 1.0 : 0.0;		this.func = func;		doIt();		return;	}	/** Construtor which uses initial directions xi. */	public ParabolicFit(Function func, double[] p, double[][] xi)				throws IllegalArgumentException {		this.p = new Vector(p);		n = p.length;		if(n!=xi.length || n!=func.length())			throw new IllegalArgumentException("Incompatible dimensions");		for(int j=0; j<n; j++)			if(n!=xi[j].length)				throw new IllegalArgumentException("Incompatible dimensions");		this.xi = xi;		this.func = func;		doIt();		return;	}	/** @return p interpolated maximum point */	public double[] getP() {return p.value();}	/** @return fret value or the function at the maximum point */	public double getFret() {return fret;}	/** @return xi direction vectors, not changed in this class */	public double[][] getXi() {return xi;}	/** @param nd number of data points to fit */	public static void setNdata(int nd) {ndata = nd; return;}	/** @param range fitting range (-range/2, range/2) */	public static void setRange(double r) {range = r; return;}	private void doIt() {		double[] x = new double[ndata], y = new double[ndata];		Random rand = new Random();		// select ndata random x values from (-range/2, range/2)		for(int i=0; i<ndata; i++)			x[i] = range*rand.nextDouble()-range/2.0;		// set up parabolic fitting function		SVD.SVDfunc fitFunc = new SVD.Parabola();		for(int j=0; j<n; j++) {			func.setP(p);			func.setXi(new Vector(xi[j]));			// get similarity measure values locations, x			for(int i=0; i<ndata; i++)				y[i] = -func.value(x[i]);	// minimizing			// singular value decomposition			SVD svd = SVD.fit(x, y, fitFunc);			double v = fitFunc.vertex(svd.getA());			// if a maximum, update p with v otherwise update with end point			if(fitFunc.maximum(svd.getA())) {				v = v<0 ? Math.max(v, -range/2.0) : Math.min(v, range/2.0);				p = p.add(new Vector(xi[j]).multiply(v));				fret = -func.value(p);	// minimizing			} else {				double fret1 = -func.value(-range/2.0),						fret2 = -func.value(range/2.0);	// minimizing				if(fret1<fret2) {					p = p.add(new Vector(xi[j]).multiply(range/2.0));					fret = fret2;				} else if(fret1>fret2) {	// if equal do nothing					p = p.add(new Vector(xi[j]).multiply(-range/2.0));					fret = fret1;				}			}		}		return;	}}	// end of ParabolicFit