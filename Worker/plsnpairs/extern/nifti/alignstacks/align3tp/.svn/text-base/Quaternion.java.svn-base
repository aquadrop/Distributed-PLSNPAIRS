package extern.nifti.alignstacks.align3tp;/** * This class represents a quaternion, which can be used for rotations in 3D. * See http://www.flipcode.com/documents/matrfaq.html * * @param axis rotation axis, normal to the plane of rotation * @param angle angle of rotation in radians * @param in rotation matrix to be xformed into a quaternion * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 23July2002 */public class Quaternion {	// {Qx, Qy, Qz, Qw}	private double[] q = new double[4];	/** constructor from quaternion components */	public Quaternion(double[] q) {		for(int i=0; i<4; i++) this.q[i] = q[i];		return;	}	/** constructor from rotation axis vector and angle */	public Quaternion(Vector axis, double angle)									throws IllegalArgumentException {		this(axis.value(), angle);		return;	}	/** constructor from rotation axis array and angle */	public Quaternion(double[] axis, double angle)									throws IllegalArgumentException {		if(axis.length<3)			throw new IllegalArgumentException("Incompatible dimension");		double mag = Math.sqrt(dot(axis, axis));		if(mag==0.0)			throw new IllegalArgumentException("Zero length vector");		for(int i=0; i<3; i++)			q[i] = axis[i]*Math.sin(angle/2.0)/mag;		q[3] = Math.cos(angle/2.0);		normalise();		return;	}	/** constructor from a rotation matrix */	public Quaternion(Matrix in) throws IllegalArgumentException {		if(in.r!=3 || in.c!=3)			throw new IllegalArgumentException("Incompatible dimensions");		// trace of 4x4 affine matrix		double trace = in.m[0][0]+in.m[1][1]+in.m[2][2]+1.0;		if(trace>0.0) {			double s = 0.5/Math.sqrt(trace);			q[0] = (in.m[2][1]-in.m[1][2])*s;			q[1] = (in.m[0][2]-in.m[2][0])*s;			q[2] = (in.m[1][0]-in.m[0][1])*s;			q[3] = 0.25/s;		} else if(in.m[0][0]>=in.m[1][1] && in.m[0][0]>=in.m[2][2]) {			double s = 2.0*Math.sqrt(1.0+in.m[0][0]-in.m[1][1]-in.m[2][2]);			q[0] = 0.5/s;			q[1] = (in.m[0][1]+in.m[1][0])/s;			q[2] = (in.m[0][2]+in.m[2][0])/s;			q[3] = (in.m[1][2]+in.m[2][1])/s;		} else if(in.m[1][1]>=in.m[2][2]) {			double s = 2.0*Math.sqrt(1.0+in.m[1][1]-in.m[0][0]-in.m[2][2]);			q[0] = (in.m[0][1]+in.m[1][0])/s;			q[1] = 0.5/s;			q[2] = (in.m[1][2]+in.m[2][1])/s;			q[3] = (in.m[0][2]+in.m[2][0])/s;		} else {			double s = 2.0*Math.sqrt(1.0+in.m[2][2]-in.m[0][0]-in.m[1][1]);			q[0] = (in.m[0][2]+in.m[2][0])/s;			q[1] = (in.m[1][2]+in.m[2][1])/s;			q[2] = 0.5/s;			q[3] = (in.m[0][1]+in.m[1][0])/s;		}		normalise();		return;	}	/** dot product for arrau of any length */	public static double dot(double[] a, double[] b) {		double out = 0.0;		for(int i=0; i<a.length; i++) out += a[i]*b[i];		return out;	}	/** cross product for first 3 elements of an array */	public static double[] cross(double[] a, double[] b) {		double[] out = new double[3];		out[0] = a[1]*b[2]-a[2]*b[1];		out[1] = a[2]*b[0]-a[0]*b[2];		out[2] = a[0]*b[1]-a[1]*b[0];		return out;	}	private Quaternion normalise() {		double mag = Math.sqrt(dot(q, q));		for(int i=0; i<4; i++) q[i] /= mag;		return this;	}	/** returns a new quaternion which is the conjugate of this */	public Quaternion conjugate() {		double[] v = new double[3];		for(int i=0; i<3; i++)			v[i] = -q[i];		return new Quaternion(v, q[3]);	}	/** quaternion multiplication */	public Quaternion multiply(Quaternion in) {		double[] inQ = in.getQ(), outQ = new double[4];		outQ[3] = q[3]*inQ[3];		for(int i=0; i<3; i++) outQ[3] -= q[i]*inQ[i];		double[] c = cross(q, inQ);		for(int i=0; i<3; i++)			outQ[i] = q[3]*inQ[i] + inQ[3]*q[i] + c[i];		return new Quaternion(outQ).normalise();	}	/** return quaternion elements */	public double[] getQ() {return q;}	/** returns the rotation axis */	public Vector getAxis() {		normalise();		double sa = Math.sqrt(1-q[3]*q[3]);		if(Math.abs(sa)<0.0005) sa = 1.0;		double[] out = new double[3];		for(int i=0; i<3; i++) out[i] = q[i]/sa;		return new Vector(out);	}	/** returns the rotation angle */	public double getAngle() {		normalise();		return 2.0*Math.acos(q[3]);	}	/** returns a rotation matrix equivalent to this */	public Matrix getMatrix() {return new Matrix(getArray());}	/** returns a rotation array equivalent to this */	public double[][] getArray() {		normalise();		double[][] m = new double[3][3];		m[0][0] = 1.0-2.0*(q[1]*q[1]+q[2]*q[2]);		m[0][1] = 2.0*(q[0]*q[1]-q[2]*q[3]);		m[0][2] = 2.0*(q[0]*q[2]+q[1]*q[3]);		m[1][0] = 2.0*(q[0]*q[1]+q[2]*q[3]);		m[1][1] = 1.0-2.0*(q[0]*q[0]+q[2]*q[2]);		m[1][2] = 2.0*(q[1]*q[2]-q[0]*q[3]);		m[2][0] = 2.0*(q[0]*q[2]-q[1]*q[3]);		m[2][1] = 2.0*(q[1]*q[2]+q[0]*q[3]);		m[2][2] = 1.0-2.0*(q[0]*q[0]+q[1]*q[1]);		return m;	}}	// end of Quaternion