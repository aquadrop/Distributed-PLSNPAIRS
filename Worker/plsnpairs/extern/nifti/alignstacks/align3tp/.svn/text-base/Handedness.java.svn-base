package extern.nifti.alignstacks.align3tp;import ij.*;import extern.nifti.alignstacks.align3tp.Matrix.*;	// import nested top-level classes/** * Handedness keeps track of the orientation of the axes so that they can * be presented in standard radiological orientations. * Assumes an axial stack as input. * If the user mirrors the image, then the axis orientation is flipped. *   Similarly, if the user draws a right-to-left or bottom-to-top *   resampling line, the axis  orientation is flipped. * Orientation can get confused on oblique orientation. * Matrix flip(Matrix xform, String axis) *   updates Handedness when user mirrors the images. * Matrix flip(Matrix xform, double theta) *   updates Handedness if necessary for resampling along a line * pitch(Matix xform) returns PI/2 or -PI/2, the pitch for rotating to *   a new plane. * static short plane(Matrix xform) *   returns closest plane for x'-y' after xform *   Axial   Coronal  Sagital *    z        y       -x *   /        /        / *   -----x   -----x   -----y *  |        |        | *  |        |        | *  y       -z       -z * note that in the axial plane theta is clockwise. * The orientations may make less sense in non-radiologic applications. * * @author J. Anthony Parker, MD PhD <J.A.Parker@IEEE.org> * @version 22January2002 * * @see Align3_TP * @see Align3_TP.Alignment * @see Align3_TP.Matrix */public class Handedness {	static final short XY_PLANE = 1, XZ_PLANE = 2, YX_PLANE = 3,			 YZ_PLANE = 4, ZX_PLANE = 5, ZY_PLANE = 6;	static final short X_AXIS = 4, Y_AXIS = 2, Z_AXIS = 1,			NO_AXIS = 0, ALL_AXES=7;	// x, y, z axis flags give mirrored state	private short flipped = 0;	public Handedness(boolean right) {		if(!right)			flipped ^= Z_AXIS;		return;	}	/**	 * Used for mirroring.	 * @param xform current orientation	 * @param axis "x", "y", or "z" for horizontal, vertical, or into	 * @return MirrorMatrix(axis)	 */	public Matrix flip(Matrix xform, String axis) {		if(axis.equalsIgnoreCase("x"))	// horizontal			switch(plane(xform)) {				case XY_PLANE:				case XZ_PLANE:					flipped ^= X_AXIS; break;				case YX_PLANE:				case YZ_PLANE:					flipped ^= Y_AXIS; break;				case ZX_PLANE:				case ZY_PLANE:					flipped ^= Z_AXIS; break;				default:		// debugging					IJ.write("Illegal plane in Handedness.flip()");					return null;			}		else if(axis.equalsIgnoreCase("y"))		// vertical			switch(plane(xform)) {				case XY_PLANE:				case ZY_PLANE:					flipped ^= Y_AXIS; break;				case XZ_PLANE:				case YZ_PLANE:					flipped ^= Z_AXIS; break;				case YX_PLANE:				case ZX_PLANE:					flipped ^= X_AXIS; break;				default:		// debugging					IJ.write("Illegal plane in Handedness.flip()");					return null;			}		else if(axis.equalsIgnoreCase("z"))		// into plane			switch(plane(xform)) {				case XY_PLANE:				case YX_PLANE:					flipped ^= Z_AXIS; break;				case XZ_PLANE:				case ZX_PLANE:					flipped ^= Y_AXIS; break;				case YZ_PLANE:				case ZY_PLANE:					flipped ^= X_AXIS; break;				default:		// debugging					IJ.write("Illegal plane in Handedness.flip()");					return null;			}		else {		// debugging			IJ.write("Illegal axis in Handedness.flip()");			return null;			}		return new MirrorMatrix(axis);	}	/**	 * Used for resampling at angle theta.	 * operations move axis, so negative to move data	 * @param xform current orientation	 * @param theta angle in current view perpendicular to which to sample	 * @return matrix which does the transformation	 */		public Matrix flip(Matrix xform, double theta) {		boolean horizontal = true;		Matrix mirror=null;		if(Math.abs(theta)<=Math.PI/4.0)						// +hor			mirror = new Matrix(3,3);		else if(Math.abs(theta)>=Math.PI*3.0/4.0) {				// -hor			theta =  theta - Math.PI;			mirror = flip(xform, "x");		} else if(Math.PI/4.0<theta && theta<Math.PI*3.0/4.0) {	// -vert			mirror = new Matrix(3,3);			horizontal = false;		} else if(-Math.PI*3.0/4.0<theta && theta<-Math.PI/4.0) {// +vert			theta = Math.PI + theta;			mirror = flip(xform, "y");			horizontal = false;		} else													// debugging			IJ.write("Illegal theta in Handedness.flip()");		switch(plane(xform)) {			case XY_PLANE:		// axial			case YX_PLANE:			// axial -> coronal: line to hor, pitch z to vert			//          roll(-theta) -> pitch(PI/2)			// axial -> sagital: line to vert, vert to hor, pitch z to vert			//          roll(PI/2-theta) -> roll(-PI/2) -> pitch(PI/2)			//          = roll(-theta) -> pitch(PI/2)				return new PitchMatrix(-Math.PI/2.0).multiply(						new RollMatrix(theta)).multiply(mirror);			case ZX_PLANE:		// coronal			case XZ_PLANE:			// coronal -> axial: line to hor, pitch y to vert			//           roll(-theta) -> pitch(-PI/2)			// coronal -> sagital: line to vert, yaw y to hor			//           roll(PI/2-theta) -> yaw(PI/2)				if(horizontal)					return new PitchMatrix(Math.PI/2.0).multiply(						new RollMatrix(theta)).multiply(mirror);				else					return new YawMatrix(-Math.PI/2.0).multiply(						new RollMatrix(theta-Math.PI/2.0)).multiply(mirror);			case YZ_PLANE:		// sagital			case ZY_PLANE:			// sagital -> axial: line to vert, yaw x to hor			//           roll(PI/2-theta) -> yaw(PI/2)			// sagital -> coronal: line to vert, yaw x to hor			//           roll(PI/2-theta) -> yaw(PI/2)				return new YawMatrix(Math.PI/2.0).multiply(						new RollMatrix(theta-Math.PI/2.0)).multiply(mirror);			default:			// debugging				IJ.write("Illegal plane in Handedness.flip()");				return null;		}	}	// axial view	public Matrix axial() {		Matrix xform = new Matrix(3,3);		if((flipped & X_AXIS)!=0)			xform.m[0][0] = -1.0;		if((flipped & Y_AXIS)!=0)			xform.m[1][1] = -1.0;		if((flipped & Z_AXIS)!=0)			xform.m[2][2] = -1.0;		return xform;	}	// x'= x, y'= -z, z'= y	public Matrix coronal() {		Matrix xform = new Matrix(3,3);		if((flipped & X_AXIS)!=0)			xform.m[0][0] = -1.0;		xform.m[1][1] = 0.0;		if((flipped & Z_AXIS)!=0)			xform.m[1][2] = 1.0;		else			xform.m[1][2] = -1.0;		xform.m[2][2] = 0.0;		if((flipped & Y_AXIS)!=0)			xform.m[2][1] = -1.0;		else			xform.m[2][1] = 1.0;		return xform;	}	// x'= y, y'= -z, z'= -x	public Matrix sagital() {		Matrix xform = new Matrix(3,3);		xform.m[0][0] = 0.0;		if((flipped & Y_AXIS)!=0)			xform.m[0][1] = -1.0;		else			xform.m[0][1] = 1.0;		xform.m[1][1] = 0.0;		if((flipped & Z_AXIS)!=0)			xform.m[1][2] = 1.0;		else			xform.m[1][2] = -1.0;		xform.m[2][2] = 0.0;		if((flipped & X_AXIS)!=0)			xform.m[2][0] = 1.0;		else			xform.m[2][0] = -1.0;		return xform;	}	/**	 * Class method which give the closest plane to the view given by xform.	 * row 0 are contributions to the output x-axis	 * row 1 are contributions to the output y-axis	 * the input axis with the largest absolute contribution is assigned	 *   to that output axis	 * @param xform current view	 * @return best plane	 */	static short plane(Matrix xform) {		double[][] absM = new double[2][3];		for(int i=0; i<2; i++)			for(int j=0; j<3; j++)				absM[i][j] = Math.abs(xform.m[i][j]);		if(absM[0][0]>=absM[0][1] && absM[0][0]>=absM[0][2])	// x_			if(absM[1][1]>=absM[1][2])		// _y				return XY_PLANE;			else							// _z				return XZ_PLANE;		else if(absM[0][1]>=absM[0][2])							// y_			if(absM[1][0]>=absM[1][2])		// _x				return YX_PLANE;			else							// _z				return YZ_PLANE;		else													//z_			if(absM[1][0]>=absM[1][1])		// _x				return ZX_PLANE;			else							// _y				return ZY_PLANE;	}	short getFlipped() {		return flipped;	}	void setFlipped(short flipped) {		this.flipped = flipped;		return;	}}